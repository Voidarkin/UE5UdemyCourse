#line 1 "__UE_FILENAME_SENTINEL__"
SamplerState D3DStaticPointClampedSampler       : register(s1, space1000);
precise float MakePrecise(in precise float v) { precise float pv = v; return pv; }
precise float2 MakePrecise(in precise float2 v) { precise float2 pv = v; return pv; }
precise float3 MakePrecise(in precise float3 v) { precise float3 pv = v; return pv; }
precise float4 MakePrecise(in precise float4 v) { precise float4 pv = v; return pv; }
bool select_internal(bool    c, bool a, bool b) { return bool (c   ? a.x : b.x); }
bool2 select_internal(bool    c, bool a, bool2 b) { return bool2(c   ? a   : b.x, c   ? a   : b.y); }
bool2 select_internal(bool    c, bool2 a, bool b) { return bool2(c   ? a.x : b  , c   ? a.y : b  ); }
bool2 select_internal(bool    c, bool2 a, bool2 b) { return bool2(c   ? a.x : b.x, c   ? a.y : b.y); }
bool2 select_internal(bool2   c, bool a, bool b) { return bool2(c.x ? a   : b  , c.y ? a   : b  ); }
bool2 select_internal(bool2   c, bool a, bool2 b) { return bool2(c.x ? a   : b.x, c.y ? a   : b.y); }
bool2 select_internal(bool2   c, bool2 a, bool b) { return bool2(c.x ? a.x : b  , c.y ? a.y : b  ); }
bool2 select_internal(bool2   c, bool2 a, bool2 b) { return bool2(c.x ? a.x : b.x, c.y ? a.y : b.y); }
bool3 select_internal(bool    c, bool a, bool3 b) { return bool3(c   ? a   : b.x, c   ? a   : b.y, c   ? a   : b.z); }
bool3 select_internal(bool    c, bool3 a, bool b) { return bool3(c   ? a.x : b  , c   ? a.y : b  , c   ? a.z : b  ); }
bool3 select_internal(bool    c, bool3 a, bool3 b) { return bool3(c   ? a.x : b.x, c   ? a.y : b.y, c   ? a.z : b.z); }
bool3 select_internal(bool3   c, bool a, bool b) { return bool3(c.x ? a   : b  , c.y ? a   : b  , c.z ? a   : b  ); }
bool3 select_internal(bool3   c, bool a, bool3 b) { return bool3(c.x ? a   : b.x, c.y ? a   : b.y, c.z ? a   : b.z); }
bool3 select_internal(bool3   c, bool3 a, bool b) { return bool3(c.x ? a.x : b  , c.y ? a.y : b  , c.z ? a.z : b  ); }
bool3 select_internal(bool3   c, bool3 a, bool3 b) { return bool3(c.x ? a.x : b.x, c.y ? a.y : b.y, c.z ? a.z : b.z); }
bool4 select_internal(bool    c, bool a, bool4 b) { return bool4(c   ? a   : b.x, c   ? a   : b.y, c   ? a   : b.z, c   ? a   : b.w); }
bool4 select_internal(bool    c, bool4 a, bool b) { return bool4(c   ? a.x : b  , c   ? a.y : b  , c   ? a.z : b  , c   ? a.w : b  ); }
bool4 select_internal(bool    c, bool4 a, bool4 b) { return bool4(c   ? a.x : b.x, c   ? a.y : b.y, c   ? a.z : b.z, c   ? a.w : b.w); }
bool4 select_internal(bool4   c, bool a, bool b) { return bool4(c.x ? a   : b  , c.y ? a   : b  , c.z ? a   : b  , c.w ? a   : b  ); }
bool4 select_internal(bool4   c, bool a, bool4 b) { return bool4(c.x ? a   : b.x, c.y ? a   : b.y, c.z ? a   : b.z, c.w ? a   : b.w); }
bool4 select_internal(bool4   c, bool4 a, bool b) { return bool4(c.x ? a.x : b  , c.y ? a.y : b  , c.z ? a.z : b  , c.w ? a.w : b  ); }
bool4 select_internal(bool4   c, bool4 a, bool4 b) { return bool4(c.x ? a.x : b.x, c.y ? a.y : b.y, c.z ? a.z : b.z, c.w ? a.w : b.w); }
int select_internal(bool    c, int a, int b) { return int (c   ? a.x : b.x); }
int2 select_internal(bool    c, int a, int2 b) { return int2(c   ? a   : b.x, c   ? a   : b.y); }
int2 select_internal(bool    c, int2 a, int b) { return int2(c   ? a.x : b  , c   ? a.y : b  ); }
int2 select_internal(bool    c, int2 a, int2 b) { return int2(c   ? a.x : b.x, c   ? a.y : b.y); }
int2 select_internal(bool2   c, int a, int b) { return int2(c.x ? a   : b  , c.y ? a   : b  ); }
int2 select_internal(bool2   c, int a, int2 b) { return int2(c.x ? a   : b.x, c.y ? a   : b.y); }
int2 select_internal(bool2   c, int2 a, int b) { return int2(c.x ? a.x : b  , c.y ? a.y : b  ); }
int2 select_internal(bool2   c, int2 a, int2 b) { return int2(c.x ? a.x : b.x, c.y ? a.y : b.y); }
int3 select_internal(bool    c, int a, int3 b) { return int3(c   ? a   : b.x, c   ? a   : b.y, c   ? a   : b.z); }
int3 select_internal(bool    c, int3 a, int b) { return int3(c   ? a.x : b  , c   ? a.y : b  , c   ? a.z : b  ); }
int3 select_internal(bool    c, int3 a, int3 b) { return int3(c   ? a.x : b.x, c   ? a.y : b.y, c   ? a.z : b.z); }
int3 select_internal(bool3   c, int a, int b) { return int3(c.x ? a   : b  , c.y ? a   : b  , c.z ? a   : b  ); }
int3 select_internal(bool3   c, int a, int3 b) { return int3(c.x ? a   : b.x, c.y ? a   : b.y, c.z ? a   : b.z); }
int3 select_internal(bool3   c, int3 a, int b) { return int3(c.x ? a.x : b  , c.y ? a.y : b  , c.z ? a.z : b  ); }
int3 select_internal(bool3   c, int3 a, int3 b) { return int3(c.x ? a.x : b.x, c.y ? a.y : b.y, c.z ? a.z : b.z); }
int4 select_internal(bool    c, int a, int4 b) { return int4(c   ? a   : b.x, c   ? a   : b.y, c   ? a   : b.z, c   ? a   : b.w); }
int4 select_internal(bool    c, int4 a, int b) { return int4(c   ? a.x : b  , c   ? a.y : b  , c   ? a.z : b  , c   ? a.w : b  ); }
int4 select_internal(bool    c, int4 a, int4 b) { return int4(c   ? a.x : b.x, c   ? a.y : b.y, c   ? a.z : b.z, c   ? a.w : b.w); }
int4 select_internal(bool4   c, int a, int b) { return int4(c.x ? a   : b  , c.y ? a   : b  , c.z ? a   : b  , c.w ? a   : b  ); }
int4 select_internal(bool4   c, int a, int4 b) { return int4(c.x ? a   : b.x, c.y ? a   : b.y, c.z ? a   : b.z, c.w ? a   : b.w); }
int4 select_internal(bool4   c, int4 a, int b) { return int4(c.x ? a.x : b  , c.y ? a.y : b  , c.z ? a.z : b  , c.w ? a.w : b  ); }
int4 select_internal(bool4   c, int4 a, int4 b) { return int4(c.x ? a.x : b.x, c.y ? a.y : b.y, c.z ? a.z : b.z, c.w ? a.w : b.w); }
float select_internal(bool    c, float a, float b) { return float (c   ? a.x : b.x); }
float2 select_internal(bool    c, float a, float2 b) { return float2(c   ? a   : b.x, c   ? a   : b.y); }
float2 select_internal(bool    c, float2 a, float b) { return float2(c   ? a.x : b  , c   ? a.y : b  ); }
float2 select_internal(bool    c, float2 a, float2 b) { return float2(c   ? a.x : b.x, c   ? a.y : b.y); }
float2 select_internal(bool2   c, float a, float b) { return float2(c.x ? a   : b  , c.y ? a   : b  ); }
float2 select_internal(bool2   c, float a, float2 b) { return float2(c.x ? a   : b.x, c.y ? a   : b.y); }
float2 select_internal(bool2   c, float2 a, float b) { return float2(c.x ? a.x : b  , c.y ? a.y : b  ); }
float2 select_internal(bool2   c, float2 a, float2 b) { return float2(c.x ? a.x : b.x, c.y ? a.y : b.y); }
float3 select_internal(bool    c, float a, float3 b) { return float3(c   ? a   : b.x, c   ? a   : b.y, c   ? a   : b.z); }
float3 select_internal(bool    c, float3 a, float b) { return float3(c   ? a.x : b  , c   ? a.y : b  , c   ? a.z : b  ); }
float3 select_internal(bool    c, float3 a, float3 b) { return float3(c   ? a.x : b.x, c   ? a.y : b.y, c   ? a.z : b.z); }
float3 select_internal(bool3   c, float a, float b) { return float3(c.x ? a   : b  , c.y ? a   : b  , c.z ? a   : b  ); }
float3 select_internal(bool3   c, float a, float3 b) { return float3(c.x ? a   : b.x, c.y ? a   : b.y, c.z ? a   : b.z); }
float3 select_internal(bool3   c, float3 a, float b) { return float3(c.x ? a.x : b  , c.y ? a.y : b  , c.z ? a.z : b  ); }
float3 select_internal(bool3   c, float3 a, float3 b) { return float3(c.x ? a.x : b.x, c.y ? a.y : b.y, c.z ? a.z : b.z); }
float4 select_internal(bool    c, float a, float4 b) { return float4(c   ? a   : b.x, c   ? a   : b.y, c   ? a   : b.z, c   ? a   : b.w); }
float4 select_internal(bool    c, float4 a, float b) { return float4(c   ? a.x : b  , c   ? a.y : b  , c   ? a.z : b  , c   ? a.w : b  ); }
float4 select_internal(bool    c, float4 a, float4 b) { return float4(c   ? a.x : b.x, c   ? a.y : b.y, c   ? a.z : b.z, c   ? a.w : b.w); }
float4 select_internal(bool4   c, float a, float b) { return float4(c.x ? a   : b  , c.y ? a   : b  , c.z ? a   : b  , c.w ? a   : b  ); }
float4 select_internal(bool4   c, float a, float4 b) { return float4(c.x ? a   : b.x, c.y ? a   : b.y, c.z ? a   : b.z, c.w ? a   : b.w); }
float4 select_internal(bool4   c, float4 a, float b) { return float4(c.x ? a.x : b  , c.y ? a.y : b  , c.z ? a.z : b  , c.w ? a.w : b  ); }
float4 select_internal(bool4   c, float4 a, float4 b) { return float4(c.x ? a.x : b.x, c.y ? a.y : b.y, c.z ? a.z : b.z, c.w ? a.w : b.w); }
bool  or_internal(bool  a, bool  b) { return bool(a || b); }
bool2 or_internal(bool2 a, bool2 b) { return bool2(a.x || b.x, a.y || b.y); }
bool3 or_internal(bool3 a, bool3 b) { return bool3(a.x || b.x, a.y || b.y, a.z || b.z); }
bool4 or_internal(bool4 a, bool4 b) { return bool4(a.x || b.x, a.y || b.y, a.z || b.z, a.w || b.w); }
#pragma warning(error: 3206)
const static float PI = 3.1415926535897932f;
const static float MaxHalfFloat = 65504.0f;
struct FDFScalar;
FDFScalar DFAdd(FDFScalar Lhs, FDFScalar Rhs);
FDFScalar DFAdd(FDFScalar Lhs, float Rhs);
FDFScalar DFSubtract(FDFScalar Lhs, FDFScalar Rhs);
FDFScalar DFSubtract(FDFScalar Lhs, float Rhs);
FDFScalar DFMultiply(FDFScalar Lhs, FDFScalar Rhs);
FDFScalar DFMultiply(FDFScalar Lhs, float Rhs);
FDFScalar DFDivide(FDFScalar Lhs, FDFScalar Rhs);
FDFScalar DFDivide(FDFScalar Lhs, float Rhs);
FDFScalar DFNegate(FDFScalar V);
float DFDemote(FDFScalar V);
struct FDFScalar
{
	float High;
	float Low;
	float Demote() { return DFDemote(this); }
};
FDFScalar MakeDFScalar(float High, float Low)
{
	FDFScalar Result;
	Result.High = High;
	Result.Low = Low;
	return Result;
}
FDFScalar DFPromote(FDFScalar Value) { return Value; }
FDFScalar DFPromote(float Value) { return MakeDFScalar(Value, (float)0); }
float DFDemote(FDFScalar Value) { return Value.High + Value.Low; }
float DFDemote(float Value) { return Value; }
FDFScalar DFNegate(FDFScalar Value)
{
	return MakeDFScalar(-Value.High, -Value.Low);
}
FDFScalar DFTwoSum(float Lhs, float Rhs)
{
	const float S =   MakePrecise( ( Lhs ) + ( Rhs ) );
	const float V =   MakePrecise( ( S ) - ( Lhs ) );
	const float Q =   MakePrecise( ( S ) - ( V ) );
	const float R =   MakePrecise( ( Lhs ) - ( Q ) );
	const float T =   MakePrecise( ( Rhs ) - ( V ) );
	const float Y =   MakePrecise( ( R ) + ( T ) );
	return MakeDFScalar(S, Y);
}
FDFScalar DFFastTwoSum(float Lhs, float Rhs)
{
	const float S =   MakePrecise( ( Lhs ) + ( Rhs ) );
	const float T =   MakePrecise( ( S ) - ( Lhs ) );
	const float E =   MakePrecise( ( Rhs ) - ( T ) );
	return MakeDFScalar(S, E);
}
FDFScalar DFAdd(float Lhs, float Rhs) { return DFTwoSum(Lhs, Rhs); }
FDFScalar DFAdd(FDFScalar Lhs, FDFScalar Rhs)
{
	FDFScalar S = DFTwoSum(Lhs.High, Rhs.High);
	const FDFScalar T = DFTwoSum(Lhs.Low, Rhs.Low);
	S.Low += T.High;
	S = DFFastTwoSum(S.High, S.Low);
	S.Low += T.Low;
	S = DFFastTwoSum(S.High, S.Low);
	return S;
}
FDFScalar DFAdd(FDFScalar Lhs, float Rhs)
{
	const FDFScalar S = DFTwoSum(Lhs.High, Rhs);
	const float T = Lhs.Low + S.Low;
	return DFFastTwoSum(S.High, T);
}
FDFScalar DFAdd(float Lhs, FDFScalar Rhs) { return DFAdd(Rhs, Lhs); }
FDFScalar DFSubtract(float Lhs, float Rhs) { return DFAdd(Lhs, -Rhs); }
FDFScalar DFSubtract(FDFScalar Lhs, FDFScalar Rhs) { return DFAdd(Lhs, DFNegate(Rhs)); }
FDFScalar DFSubtract(FDFScalar Lhs, float Rhs) { return DFAdd(Lhs, -Rhs); }
FDFScalar DFSubtract(float Lhs, FDFScalar Rhs) { return DFAdd(Lhs, DFNegate(Rhs)); }
float DFFastLocalSubtractDemote(FDFScalar Lhs, FDFScalar Rhs)
{
	const float High =   MakePrecise( ( Lhs.High ) - ( Rhs.High ) );
	const float Low =   MakePrecise( ( Lhs.Low ) - ( Rhs.Low ) );
	const float Sum =   MakePrecise( ( High ) + ( Low ) );
	return Sum;
}
float DFFastLocalSubtractDemote(FDFScalar Lhs, float Rhs)
{
	const float High =   MakePrecise( ( Lhs.High ) - ( Rhs ) );
	const float Sum =   MakePrecise( ( High ) + ( Lhs.Low ) );
	return Sum;
}
float DFFastLocalSubtractDemote(float Lhs, FDFScalar Rhs)
{
	return DFFastLocalSubtractDemote(DFPromote(Lhs), Rhs);
}
FDFScalar DFTwoProduct(float Lhs, float Rhs)
{
	const float P = Lhs * Rhs;
	const float E =   MakePrecise(  mad( ( Lhs ) , ( Rhs ) , ( -P ) ) );
	return MakeDFScalar(P, E);
}
FDFScalar DFMultiply(float Lhs, float Rhs) { return DFTwoProduct(Lhs, Rhs); }
FDFScalar DFMultiply(FDFScalar Lhs, FDFScalar Rhs)
{
	const FDFScalar P = DFTwoProduct(Lhs.High, Rhs.High);
	float T =   MakePrecise( ( Lhs.High ) * ( Rhs.Low ) );
	T =   MakePrecise(  mad( ( Lhs.Low ) , ( Rhs.High ) , ( T ) ) );
	T =   MakePrecise( ( T ) + ( P.Low ) );
	return DFFastTwoSum(P.High, T);
}
FDFScalar DFMultiply(FDFScalar Lhs, float Rhs)
{
	FDFScalar P = DFTwoProduct(Lhs.High, Rhs);
	float T =   MakePrecise(  mad( ( Lhs.Low ) , ( Rhs ) , ( P.Low ) ) );
	return DFFastTwoSum(P.High, T);
}
FDFScalar DFMultiply(float Lhs, FDFScalar Rhs) { return DFMultiply(Rhs, Lhs); }
FDFScalar DFFastDivide(FDFScalar Lhs, FDFScalar Rhs);
FDFScalar DFDivide(FDFScalar Lhs, FDFScalar Rhs)
{
	const float Th =   MakePrecise( ( 1.0 ) / ( Rhs.High ) );
	const float Rh =   MakePrecise(  mad( ( -Rhs.High ) , ( Th ) , ( (float)1 ) ) );
	const float Rl =   MakePrecise( ( -Rhs.Low ) * ( Th ) );
	const FDFScalar E = DFFastTwoSum(Rh, Rl);
	const FDFScalar D = DFMultiply(E, Th);
	const FDFScalar M = DFAdd(D, Th);
	return DFMultiply(Lhs, M);
}
FDFScalar DFDivide(FDFScalar Lhs, float Rhs)
{
	const float Th =   MakePrecise( ( Lhs.High ) / ( Rhs ) );
	const FDFScalar P = DFTwoProduct(Th, Rhs);
	const float Dh =   MakePrecise( ( Lhs.High ) - ( P.High ) );
	const float Dt =   MakePrecise( ( Dh ) - ( P.Low ) );
	const float D =   MakePrecise( ( Dt ) + ( Lhs.Low ) );
	const float Tl =   MakePrecise( ( D ) / ( Rhs ) );
	return DFFastTwoSum(Th, Tl);
}
FDFScalar DFDivide(float Lhs, float Rhs)
{
	return DFDivide(DFPromote(Lhs), Rhs);
}
FDFScalar DFDivide(float Lhs, FDFScalar Rhs)
{
	return DFDivide(DFPromote(Lhs), Rhs);
}
FDFScalar DFFastDivide(FDFScalar Lhs, FDFScalar Rhs)
{
	const float Th =   MakePrecise( ( Lhs.High ) / ( Rhs.High ) );
	const FDFScalar R = DFMultiply(Rhs, Th);
	const float Ph =   MakePrecise( ( Lhs.High ) - ( R.High ) );
	const float Dl =   MakePrecise( ( Lhs.Low ) - ( R.Low ) );
	const float D =   MakePrecise( ( Ph ) + ( Dl ) );
	const float Tl =   MakePrecise( ( D ) / ( Rhs.High ) );
	return DFFastTwoSum(Th, Tl);
}
FDFScalar DFFastDivide(FDFScalar Lhs, float Rhs)
{
	const float Th =   MakePrecise( ( Lhs.High ) / ( Rhs ) );
	const FDFScalar R = DFTwoProduct(Rhs, Th);
	const float Ph =   MakePrecise( ( Lhs.High ) - ( R.High ) );
	const float Dl =   MakePrecise( ( Lhs.Low ) - ( R.Low ) );
	const float D =   MakePrecise( ( Ph ) + ( Dl ) );
	const float Tl =   MakePrecise( ( D ) / ( Rhs ) );
	return DFFastTwoSum(Th, Tl);
}
FDFScalar DFFastDivide(float Lhs, FDFScalar Rhs) { return DFFastDivide(DFPromote(Lhs), Rhs); }
FDFScalar DFFastDivide(float Lhs, float Rhs) { return DFFastDivide(DFPromote(Lhs), Rhs); }
FDFScalar DFGetComponent(float V, int C) { return MakeDFScalar(V, 0); }
FDFScalar DFGetComponent(FDFScalar V, int C) { return V; }
struct FDFVector2;
FDFVector2 DFBroadcast2(FDFScalar V);
float2 DFBroadcast2(float V);
FDFScalar DFGetComponent(FDFVector2 V, int C);
FDFVector2 DFNegate(FDFVector2 In);
FDFVector2 DFAdd (FDFVector2 Lhs, FDFVector2 Rhs);
FDFVector2 DFAdd (FDFVector2 Lhs, float2 Rhs);
FDFVector2 DFAdd (FDFVector2 Lhs, FDFScalar Rhs);
FDFVector2 DFAdd (FDFVector2 Lhs, float Rhs);
FDFVector2 DFSubtract (FDFVector2 Lhs, FDFVector2 Rhs);
FDFVector2 DFSubtract (FDFVector2 Lhs, float2 Rhs);
FDFVector2 DFSubtract (FDFVector2 Lhs, FDFScalar Rhs);
FDFVector2 DFSubtract (FDFVector2 Lhs, float Rhs);
FDFVector2 DFMultiply (FDFVector2 Lhs, FDFVector2 Rhs);
FDFVector2 DFMultiply (FDFVector2 Lhs, float2 Rhs);
FDFVector2 DFMultiply (FDFVector2 Lhs, FDFScalar Rhs);
FDFVector2 DFMultiply (FDFVector2 Lhs, float Rhs);
FDFVector2 DFDivide (FDFVector2 Lhs, FDFVector2 Rhs);
FDFVector2 DFDivide (FDFVector2 Lhs, float2 Rhs);
FDFVector2 DFDivide (FDFVector2 Lhs, FDFScalar Rhs);
FDFVector2 DFDivide (FDFVector2 Lhs, float Rhs);
float2 DFDemote(FDFVector2 In);
struct FDFVector2
{
	float2 High;
	float2 Low;
	float2 Demote() { return DFDemote(this); }
};
FDFScalar DFGetComponent(FDFVector2 V, int C) { return MakeDFScalar(V.High[C], V.Low[C]); }
FDFVector2 MakeDFVector2(float2 High, float2 Low)
{
	FDFVector2 Result;
	Result.High = High;
	Result.Low = Low;
	return Result;
}
FDFVector2 DFPromote(FDFVector2 Value) { return Value; }
FDFVector2 DFPromote(float2 Value) { return MakeDFVector2(Value, (float2)0); }
float2 DFDemote(FDFVector2 Value) { return Value.High + Value.Low; }
float2 DFDemote(float2 Value) { return Value; }
FDFVector2 DFNegate(FDFVector2 Value)
{
	return MakeDFVector2(-Value.High, -Value.Low);
}
FDFVector2 DFTwoSum(float2 Lhs, float2 Rhs)
{
	const float2 S =   MakePrecise( ( Lhs ) + ( Rhs ) );
	const float2 V =   MakePrecise( ( S ) - ( Lhs ) );
	const float2 Q =   MakePrecise( ( S ) - ( V ) );
	const float2 R =   MakePrecise( ( Lhs ) - ( Q ) );
	const float2 T =   MakePrecise( ( Rhs ) - ( V ) );
	const float2 Y =   MakePrecise( ( R ) + ( T ) );
	return MakeDFVector2(S, Y);
}
FDFVector2 DFFastTwoSum(float2 Lhs, float2 Rhs)
{
	const float2 S =   MakePrecise( ( Lhs ) + ( Rhs ) );
	const float2 T =   MakePrecise( ( S ) - ( Lhs ) );
	const float2 E =   MakePrecise( ( Rhs ) - ( T ) );
	return MakeDFVector2(S, E);
}
FDFVector2 DFAdd(float2 Lhs, float2 Rhs) { return DFTwoSum(Lhs, Rhs); }
FDFVector2 DFAdd(FDFVector2 Lhs, FDFVector2 Rhs)
{
	FDFVector2 S = DFTwoSum(Lhs.High, Rhs.High);
	const FDFVector2 T = DFTwoSum(Lhs.Low, Rhs.Low);
	S.Low += T.High;
	S = DFFastTwoSum(S.High, S.Low);
	S.Low += T.Low;
	S = DFFastTwoSum(S.High, S.Low);
	return S;
}
FDFVector2 DFAdd(FDFVector2 Lhs, float2 Rhs)
{
	const FDFVector2 S = DFTwoSum(Lhs.High, Rhs);
	const float2 T = Lhs.Low + S.Low;
	return DFFastTwoSum(S.High, T);
}
FDFVector2 DFAdd(float2 Lhs, FDFVector2 Rhs) { return DFAdd(Rhs, Lhs); }
FDFVector2 DFSubtract(float2 Lhs, float2 Rhs) { return DFAdd(Lhs, -Rhs); }
FDFVector2 DFSubtract(FDFVector2 Lhs, FDFVector2 Rhs) { return DFAdd(Lhs, DFNegate(Rhs)); }
FDFVector2 DFSubtract(FDFVector2 Lhs, float2 Rhs) { return DFAdd(Lhs, -Rhs); }
FDFVector2 DFSubtract(float2 Lhs, FDFVector2 Rhs) { return DFAdd(Lhs, DFNegate(Rhs)); }
float2 DFFastLocalSubtractDemote(FDFVector2 Lhs, FDFVector2 Rhs)
{
	const float2 High =   MakePrecise( ( Lhs.High ) - ( Rhs.High ) );
	const float2 Low =   MakePrecise( ( Lhs.Low ) - ( Rhs.Low ) );
	const float2 Sum =   MakePrecise( ( High ) + ( Low ) );
	return Sum;
}
float2 DFFastLocalSubtractDemote(FDFVector2 Lhs, float2 Rhs)
{
	const float2 High =   MakePrecise( ( Lhs.High ) - ( Rhs ) );
	const float2 Sum =   MakePrecise( ( High ) + ( Lhs.Low ) );
	return Sum;
}
float2 DFFastLocalSubtractDemote(float2 Lhs, FDFVector2 Rhs)
{
	return DFFastLocalSubtractDemote(DFPromote(Lhs), Rhs);
}
FDFVector2 DFTwoProduct(float2 Lhs, float2 Rhs)
{
	const float2 P = Lhs * Rhs;
	const float2 E =   MakePrecise(  mad( ( Lhs ) , ( Rhs ) , ( -P ) ) );
	return MakeDFVector2(P, E);
}
FDFVector2 DFMultiply(float2 Lhs, float2 Rhs) { return DFTwoProduct(Lhs, Rhs); }
FDFVector2 DFMultiply(FDFVector2 Lhs, FDFVector2 Rhs)
{
	const FDFVector2 P = DFTwoProduct(Lhs.High, Rhs.High);
	float2 T =   MakePrecise( ( Lhs.High ) * ( Rhs.Low ) );
	T =   MakePrecise(  mad( ( Lhs.Low ) , ( Rhs.High ) , ( T ) ) );
	T =   MakePrecise( ( T ) + ( P.Low ) );
	return DFFastTwoSum(P.High, T);
}
FDFVector2 DFMultiply(FDFVector2 Lhs, float2 Rhs)
{
	FDFVector2 P = DFTwoProduct(Lhs.High, Rhs);
	float2 T =   MakePrecise(  mad( ( Lhs.Low ) , ( Rhs ) , ( P.Low ) ) );
	return DFFastTwoSum(P.High, T);
}
FDFVector2 DFMultiply(float2 Lhs, FDFVector2 Rhs) { return DFMultiply(Rhs, Lhs); }
FDFVector2 DFFastDivide(FDFVector2 Lhs, FDFVector2 Rhs);
FDFVector2 DFDivide(FDFVector2 Lhs, FDFVector2 Rhs)
{
	const float2 Th =   MakePrecise( ( 1.0 ) / ( Rhs.High ) );
	const float2 Rh =   MakePrecise(  mad( ( -Rhs.High ) , ( Th ) , ( (float2)1 ) ) );
	const float2 Rl =   MakePrecise( ( -Rhs.Low ) * ( Th ) );
	const FDFVector2 E = DFFastTwoSum(Rh, Rl);
	const FDFVector2 D = DFMultiply(E, Th);
	const FDFVector2 M = DFAdd(D, Th);
	return DFMultiply(Lhs, M);
}
FDFVector2 DFDivide(FDFVector2 Lhs, float2 Rhs)
{
	const float2 Th =   MakePrecise( ( Lhs.High ) / ( Rhs ) );
	const FDFVector2 P = DFTwoProduct(Th, Rhs);
	const float2 Dh =   MakePrecise( ( Lhs.High ) - ( P.High ) );
	const float2 Dt =   MakePrecise( ( Dh ) - ( P.Low ) );
	const float2 D =   MakePrecise( ( Dt ) + ( Lhs.Low ) );
	const float2 Tl =   MakePrecise( ( D ) / ( Rhs ) );
	return DFFastTwoSum(Th, Tl);
}
FDFVector2 DFDivide(float2 Lhs, float2 Rhs)
{
	return DFDivide(DFPromote(Lhs), Rhs);
}
FDFVector2 DFDivide(float2 Lhs, FDFVector2 Rhs)
{
	return DFDivide(DFPromote(Lhs), Rhs);
}
FDFVector2 DFFastDivide(FDFVector2 Lhs, FDFVector2 Rhs)
{
	const float2 Th =   MakePrecise( ( Lhs.High ) / ( Rhs.High ) );
	const FDFVector2 R = DFMultiply(Rhs, Th);
	const float2 Ph =   MakePrecise( ( Lhs.High ) - ( R.High ) );
	const float2 Dl =   MakePrecise( ( Lhs.Low ) - ( R.Low ) );
	const float2 D =   MakePrecise( ( Ph ) + ( Dl ) );
	const float2 Tl =   MakePrecise( ( D ) / ( Rhs.High ) );
	return DFFastTwoSum(Th, Tl);
}
FDFVector2 DFFastDivide(FDFVector2 Lhs, float2 Rhs)
{
	const float2 Th =   MakePrecise( ( Lhs.High ) / ( Rhs ) );
	const FDFVector2 R = DFTwoProduct(Rhs, Th);
	const float2 Ph =   MakePrecise( ( Lhs.High ) - ( R.High ) );
	const float2 Dl =   MakePrecise( ( Lhs.Low ) - ( R.Low ) );
	const float2 D =   MakePrecise( ( Ph ) + ( Dl ) );
	const float2 Tl =   MakePrecise( ( D ) / ( Rhs ) );
	return DFFastTwoSum(Th, Tl);
}
FDFVector2 DFFastDivide(float2 Lhs, FDFVector2 Rhs) { return DFFastDivide(DFPromote(Lhs), Rhs); }
FDFVector2 DFFastDivide(float2 Lhs, float2 Rhs) { return DFFastDivide(DFPromote(Lhs), Rhs); }
FDFVector2 DFBroadcast2(FDFScalar V)
{
	const float2 High = V.High;
	const float2 Low = V.Low;
	return MakeDFVector2(High, Low);
}
float2 DFBroadcast2(float V)
{
	const float2 Single = V;
	return Single;
}
FDFVector2  DFAdd (FDFScalar Lhs, FDFVector2 Rhs) { return DFAdd (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFAdd (float Lhs, FDFVector2 Rhs) { return DFAdd (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFAdd (FDFScalar Lhs, float2 Rhs) { return DFAdd (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFAdd (float Lhs, float2 Rhs) { return DFAdd (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFAdd (FDFVector2 Lhs, FDFScalar Rhs) { return DFAdd (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFAdd (FDFVector2 Lhs, float Rhs)     { return DFAdd (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFAdd (float2 Lhs, FDFScalar Rhs) { return DFAdd (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFAdd (float2 Lhs, float Rhs) { return DFAdd (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFSubtract (FDFScalar Lhs, FDFVector2 Rhs) { return DFSubtract (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFSubtract (float Lhs, FDFVector2 Rhs) { return DFSubtract (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFSubtract (FDFScalar Lhs, float2 Rhs) { return DFSubtract (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFSubtract (float Lhs, float2 Rhs) { return DFSubtract (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFSubtract (FDFVector2 Lhs, FDFScalar Rhs) { return DFSubtract (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFSubtract (FDFVector2 Lhs, float Rhs)     { return DFSubtract (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFSubtract (float2 Lhs, FDFScalar Rhs) { return DFSubtract (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFSubtract (float2 Lhs, float Rhs) { return DFSubtract (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFMultiply (FDFScalar Lhs, FDFVector2 Rhs) { return DFMultiply (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFMultiply (float Lhs, FDFVector2 Rhs) { return DFMultiply (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFMultiply (FDFScalar Lhs, float2 Rhs) { return DFMultiply (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFMultiply (float Lhs, float2 Rhs) { return DFMultiply (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFMultiply (FDFVector2 Lhs, FDFScalar Rhs) { return DFMultiply (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFMultiply (FDFVector2 Lhs, float Rhs)     { return DFMultiply (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFMultiply (float2 Lhs, FDFScalar Rhs) { return DFMultiply (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFMultiply (float2 Lhs, float Rhs) { return DFMultiply (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFDivide (FDFScalar Lhs, FDFVector2 Rhs) { return DFDivide (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFDivide (float Lhs, FDFVector2 Rhs) { return DFDivide (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFDivide (FDFScalar Lhs, float2 Rhs) { return DFDivide (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFDivide (float Lhs, float2 Rhs) { return DFDivide (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFDivide (FDFVector2 Lhs, FDFScalar Rhs) { return DFDivide (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFDivide (FDFVector2 Lhs, float Rhs)     { return DFDivide (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFDivide (float2 Lhs, FDFScalar Rhs) { return DFDivide (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFDivide (float2 Lhs, float Rhs) { return DFDivide (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFFastDivide (FDFScalar Lhs, FDFVector2 Rhs) { return DFFastDivide (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFFastDivide (float Lhs, FDFVector2 Rhs) { return DFFastDivide (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFFastDivide (FDFScalar Lhs, float2 Rhs) { return DFFastDivide (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFFastDivide (float Lhs, float2 Rhs) { return DFFastDivide (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFFastDivide (FDFVector2 Lhs, FDFScalar Rhs) { return DFFastDivide (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFFastDivide (FDFVector2 Lhs, float Rhs)     { return DFFastDivide (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFFastDivide (float2 Lhs, FDFScalar Rhs) { return DFFastDivide (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFFastDivide (float2 Lhs, float Rhs) { return DFFastDivide (Lhs, DFBroadcast2(Rhs)); }
struct FDFVector3;
FDFVector3 DFBroadcast3(FDFScalar V);
float3 DFBroadcast3(float V);
FDFScalar DFGetComponent(FDFVector3 V, int C);
FDFVector3 DFNegate(FDFVector3 In);
FDFVector3 DFAdd (FDFVector3 Lhs, FDFVector3 Rhs);
FDFVector3 DFAdd (FDFVector3 Lhs, float3 Rhs);
FDFVector3 DFAdd (FDFVector3 Lhs, FDFScalar Rhs);
FDFVector3 DFAdd (FDFVector3 Lhs, float Rhs);
FDFVector3 DFSubtract (FDFVector3 Lhs, FDFVector3 Rhs);
FDFVector3 DFSubtract (FDFVector3 Lhs, float3 Rhs);
FDFVector3 DFSubtract (FDFVector3 Lhs, FDFScalar Rhs);
FDFVector3 DFSubtract (FDFVector3 Lhs, float Rhs);
FDFVector3 DFMultiply (FDFVector3 Lhs, FDFVector3 Rhs);
FDFVector3 DFMultiply (FDFVector3 Lhs, float3 Rhs);
FDFVector3 DFMultiply (FDFVector3 Lhs, FDFScalar Rhs);
FDFVector3 DFMultiply (FDFVector3 Lhs, float Rhs);
FDFVector3 DFDivide (FDFVector3 Lhs, FDFVector3 Rhs);
FDFVector3 DFDivide (FDFVector3 Lhs, float3 Rhs);
FDFVector3 DFDivide (FDFVector3 Lhs, FDFScalar Rhs);
FDFVector3 DFDivide (FDFVector3 Lhs, float Rhs);
float3 DFDemote(FDFVector3 In);
struct FDFVector3
{
	float3 High;
	float3 Low;
	float3 Demote() { return DFDemote(this); }
};
FDFScalar DFGetComponent(FDFVector3 V, int C) { return MakeDFScalar(V.High[C], V.Low[C]); }
FDFVector3 MakeDFVector3(float3 High, float3 Low)
{
	FDFVector3 Result;
	Result.High = High;
	Result.Low = Low;
	return Result;
}
FDFVector3 DFPromote(FDFVector3 Value) { return Value; }
FDFVector3 DFPromote(float3 Value) { return MakeDFVector3(Value, (float3)0); }
float3 DFDemote(FDFVector3 Value) { return Value.High + Value.Low; }
float3 DFDemote(float3 Value) { return Value; }
FDFVector3 DFNegate(FDFVector3 Value)
{
	return MakeDFVector3(-Value.High, -Value.Low);
}
FDFVector3 DFTwoSum(float3 Lhs, float3 Rhs)
{
	const float3 S =   MakePrecise( ( Lhs ) + ( Rhs ) );
	const float3 V =   MakePrecise( ( S ) - ( Lhs ) );
	const float3 Q =   MakePrecise( ( S ) - ( V ) );
	const float3 R =   MakePrecise( ( Lhs ) - ( Q ) );
	const float3 T =   MakePrecise( ( Rhs ) - ( V ) );
	const float3 Y =   MakePrecise( ( R ) + ( T ) );
	return MakeDFVector3(S, Y);
}
FDFVector3 DFFastTwoSum(float3 Lhs, float3 Rhs)
{
	const float3 S =   MakePrecise( ( Lhs ) + ( Rhs ) );
	const float3 T =   MakePrecise( ( S ) - ( Lhs ) );
	const float3 E =   MakePrecise( ( Rhs ) - ( T ) );
	return MakeDFVector3(S, E);
}
FDFVector3 DFAdd(float3 Lhs, float3 Rhs) { return DFTwoSum(Lhs, Rhs); }
FDFVector3 DFAdd(FDFVector3 Lhs, FDFVector3 Rhs)
{
	FDFVector3 S = DFTwoSum(Lhs.High, Rhs.High);
	const FDFVector3 T = DFTwoSum(Lhs.Low, Rhs.Low);
	S.Low += T.High;
	S = DFFastTwoSum(S.High, S.Low);
	S.Low += T.Low;
	S = DFFastTwoSum(S.High, S.Low);
	return S;
}
FDFVector3 DFAdd(FDFVector3 Lhs, float3 Rhs)
{
	const FDFVector3 S = DFTwoSum(Lhs.High, Rhs);
	const float3 T = Lhs.Low + S.Low;
	return DFFastTwoSum(S.High, T);
}
FDFVector3 DFAdd(float3 Lhs, FDFVector3 Rhs) { return DFAdd(Rhs, Lhs); }
FDFVector3 DFSubtract(float3 Lhs, float3 Rhs) { return DFAdd(Lhs, -Rhs); }
FDFVector3 DFSubtract(FDFVector3 Lhs, FDFVector3 Rhs) { return DFAdd(Lhs, DFNegate(Rhs)); }
FDFVector3 DFSubtract(FDFVector3 Lhs, float3 Rhs) { return DFAdd(Lhs, -Rhs); }
FDFVector3 DFSubtract(float3 Lhs, FDFVector3 Rhs) { return DFAdd(Lhs, DFNegate(Rhs)); }
float3 DFFastLocalSubtractDemote(FDFVector3 Lhs, FDFVector3 Rhs)
{
	const float3 High =   MakePrecise( ( Lhs.High ) - ( Rhs.High ) );
	const float3 Low =   MakePrecise( ( Lhs.Low ) - ( Rhs.Low ) );
	const float3 Sum =   MakePrecise( ( High ) + ( Low ) );
	return Sum;
}
float3 DFFastLocalSubtractDemote(FDFVector3 Lhs, float3 Rhs)
{
	const float3 High =   MakePrecise( ( Lhs.High ) - ( Rhs ) );
	const float3 Sum =   MakePrecise( ( High ) + ( Lhs.Low ) );
	return Sum;
}
float3 DFFastLocalSubtractDemote(float3 Lhs, FDFVector3 Rhs)
{
	return DFFastLocalSubtractDemote(DFPromote(Lhs), Rhs);
}
FDFVector3 DFTwoProduct(float3 Lhs, float3 Rhs)
{
	const float3 P = Lhs * Rhs;
	const float3 E =   MakePrecise(  mad( ( Lhs ) , ( Rhs ) , ( -P ) ) );
	return MakeDFVector3(P, E);
}
FDFVector3 DFMultiply(float3 Lhs, float3 Rhs) { return DFTwoProduct(Lhs, Rhs); }
FDFVector3 DFMultiply(FDFVector3 Lhs, FDFVector3 Rhs)
{
	const FDFVector3 P = DFTwoProduct(Lhs.High, Rhs.High);
	float3 T =   MakePrecise( ( Lhs.High ) * ( Rhs.Low ) );
	T =   MakePrecise(  mad( ( Lhs.Low ) , ( Rhs.High ) , ( T ) ) );
	T =   MakePrecise( ( T ) + ( P.Low ) );
	return DFFastTwoSum(P.High, T);
}
FDFVector3 DFMultiply(FDFVector3 Lhs, float3 Rhs)
{
	FDFVector3 P = DFTwoProduct(Lhs.High, Rhs);
	float3 T =   MakePrecise(  mad( ( Lhs.Low ) , ( Rhs ) , ( P.Low ) ) );
	return DFFastTwoSum(P.High, T);
}
FDFVector3 DFMultiply(float3 Lhs, FDFVector3 Rhs) { return DFMultiply(Rhs, Lhs); }
FDFVector3 DFFastDivide(FDFVector3 Lhs, FDFVector3 Rhs);
FDFVector3 DFDivide(FDFVector3 Lhs, FDFVector3 Rhs)
{
	const float3 Th =   MakePrecise( ( 1.0 ) / ( Rhs.High ) );
	const float3 Rh =   MakePrecise(  mad( ( -Rhs.High ) , ( Th ) , ( (float3)1 ) ) );
	const float3 Rl =   MakePrecise( ( -Rhs.Low ) * ( Th ) );
	const FDFVector3 E = DFFastTwoSum(Rh, Rl);
	const FDFVector3 D = DFMultiply(E, Th);
	const FDFVector3 M = DFAdd(D, Th);
	return DFMultiply(Lhs, M);
}
FDFVector3 DFDivide(FDFVector3 Lhs, float3 Rhs)
{
	const float3 Th =   MakePrecise( ( Lhs.High ) / ( Rhs ) );
	const FDFVector3 P = DFTwoProduct(Th, Rhs);
	const float3 Dh =   MakePrecise( ( Lhs.High ) - ( P.High ) );
	const float3 Dt =   MakePrecise( ( Dh ) - ( P.Low ) );
	const float3 D =   MakePrecise( ( Dt ) + ( Lhs.Low ) );
	const float3 Tl =   MakePrecise( ( D ) / ( Rhs ) );
	return DFFastTwoSum(Th, Tl);
}
FDFVector3 DFDivide(float3 Lhs, float3 Rhs)
{
	return DFDivide(DFPromote(Lhs), Rhs);
}
FDFVector3 DFDivide(float3 Lhs, FDFVector3 Rhs)
{
	return DFDivide(DFPromote(Lhs), Rhs);
}
FDFVector3 DFFastDivide(FDFVector3 Lhs, FDFVector3 Rhs)
{
	const float3 Th =   MakePrecise( ( Lhs.High ) / ( Rhs.High ) );
	const FDFVector3 R = DFMultiply(Rhs, Th);
	const float3 Ph =   MakePrecise( ( Lhs.High ) - ( R.High ) );
	const float3 Dl =   MakePrecise( ( Lhs.Low ) - ( R.Low ) );
	const float3 D =   MakePrecise( ( Ph ) + ( Dl ) );
	const float3 Tl =   MakePrecise( ( D ) / ( Rhs.High ) );
	return DFFastTwoSum(Th, Tl);
}
FDFVector3 DFFastDivide(FDFVector3 Lhs, float3 Rhs)
{
	const float3 Th =   MakePrecise( ( Lhs.High ) / ( Rhs ) );
	const FDFVector3 R = DFTwoProduct(Rhs, Th);
	const float3 Ph =   MakePrecise( ( Lhs.High ) - ( R.High ) );
	const float3 Dl =   MakePrecise( ( Lhs.Low ) - ( R.Low ) );
	const float3 D =   MakePrecise( ( Ph ) + ( Dl ) );
	const float3 Tl =   MakePrecise( ( D ) / ( Rhs ) );
	return DFFastTwoSum(Th, Tl);
}
FDFVector3 DFFastDivide(float3 Lhs, FDFVector3 Rhs) { return DFFastDivide(DFPromote(Lhs), Rhs); }
FDFVector3 DFFastDivide(float3 Lhs, float3 Rhs) { return DFFastDivide(DFPromote(Lhs), Rhs); }
FDFVector3 DFBroadcast3(FDFScalar V)
{
	const float3 High = V.High;
	const float3 Low = V.Low;
	return MakeDFVector3(High, Low);
}
float3 DFBroadcast3(float V)
{
	const float3 Single = V;
	return Single;
}
FDFVector3  DFAdd (FDFScalar Lhs, FDFVector3 Rhs) { return DFAdd (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFAdd (float Lhs, FDFVector3 Rhs) { return DFAdd (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFAdd (FDFScalar Lhs, float3 Rhs) { return DFAdd (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFAdd (float Lhs, float3 Rhs) { return DFAdd (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFAdd (FDFVector3 Lhs, FDFScalar Rhs) { return DFAdd (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFAdd (FDFVector3 Lhs, float Rhs)     { return DFAdd (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFAdd (float3 Lhs, FDFScalar Rhs) { return DFAdd (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFAdd (float3 Lhs, float Rhs) { return DFAdd (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFSubtract (FDFScalar Lhs, FDFVector3 Rhs) { return DFSubtract (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFSubtract (float Lhs, FDFVector3 Rhs) { return DFSubtract (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFSubtract (FDFScalar Lhs, float3 Rhs) { return DFSubtract (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFSubtract (float Lhs, float3 Rhs) { return DFSubtract (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFSubtract (FDFVector3 Lhs, FDFScalar Rhs) { return DFSubtract (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFSubtract (FDFVector3 Lhs, float Rhs)     { return DFSubtract (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFSubtract (float3 Lhs, FDFScalar Rhs) { return DFSubtract (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFSubtract (float3 Lhs, float Rhs) { return DFSubtract (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFMultiply (FDFScalar Lhs, FDFVector3 Rhs) { return DFMultiply (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFMultiply (float Lhs, FDFVector3 Rhs) { return DFMultiply (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFMultiply (FDFScalar Lhs, float3 Rhs) { return DFMultiply (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFMultiply (float Lhs, float3 Rhs) { return DFMultiply (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFMultiply (FDFVector3 Lhs, FDFScalar Rhs) { return DFMultiply (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFMultiply (FDFVector3 Lhs, float Rhs)     { return DFMultiply (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFMultiply (float3 Lhs, FDFScalar Rhs) { return DFMultiply (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFMultiply (float3 Lhs, float Rhs) { return DFMultiply (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFDivide (FDFScalar Lhs, FDFVector3 Rhs) { return DFDivide (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFDivide (float Lhs, FDFVector3 Rhs) { return DFDivide (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFDivide (FDFScalar Lhs, float3 Rhs) { return DFDivide (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFDivide (float Lhs, float3 Rhs) { return DFDivide (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFDivide (FDFVector3 Lhs, FDFScalar Rhs) { return DFDivide (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFDivide (FDFVector3 Lhs, float Rhs)     { return DFDivide (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFDivide (float3 Lhs, FDFScalar Rhs) { return DFDivide (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFDivide (float3 Lhs, float Rhs) { return DFDivide (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFFastDivide (FDFScalar Lhs, FDFVector3 Rhs) { return DFFastDivide (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFFastDivide (float Lhs, FDFVector3 Rhs) { return DFFastDivide (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFFastDivide (FDFScalar Lhs, float3 Rhs) { return DFFastDivide (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFFastDivide (float Lhs, float3 Rhs) { return DFFastDivide (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFFastDivide (FDFVector3 Lhs, FDFScalar Rhs) { return DFFastDivide (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFFastDivide (FDFVector3 Lhs, float Rhs)     { return DFFastDivide (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFFastDivide (float3 Lhs, FDFScalar Rhs) { return DFFastDivide (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFFastDivide (float3 Lhs, float Rhs) { return DFFastDivide (Lhs, DFBroadcast3(Rhs)); }
struct FDFVector4;
FDFVector4 DFBroadcast4(FDFScalar V);
float4 DFBroadcast4(float V);
FDFScalar DFGetComponent(FDFVector4 V, int C);
FDFVector4 DFNegate(FDFVector4 In);
FDFVector4 DFAdd (FDFVector4 Lhs, FDFVector4 Rhs);
FDFVector4 DFAdd (FDFVector4 Lhs, float4 Rhs);
FDFVector4 DFAdd (FDFVector4 Lhs, FDFScalar Rhs);
FDFVector4 DFAdd (FDFVector4 Lhs, float Rhs);
FDFVector4 DFSubtract (FDFVector4 Lhs, FDFVector4 Rhs);
FDFVector4 DFSubtract (FDFVector4 Lhs, float4 Rhs);
FDFVector4 DFSubtract (FDFVector4 Lhs, FDFScalar Rhs);
FDFVector4 DFSubtract (FDFVector4 Lhs, float Rhs);
FDFVector4 DFMultiply (FDFVector4 Lhs, FDFVector4 Rhs);
FDFVector4 DFMultiply (FDFVector4 Lhs, float4 Rhs);
FDFVector4 DFMultiply (FDFVector4 Lhs, FDFScalar Rhs);
FDFVector4 DFMultiply (FDFVector4 Lhs, float Rhs);
FDFVector4 DFDivide (FDFVector4 Lhs, FDFVector4 Rhs);
FDFVector4 DFDivide (FDFVector4 Lhs, float4 Rhs);
FDFVector4 DFDivide (FDFVector4 Lhs, FDFScalar Rhs);
FDFVector4 DFDivide (FDFVector4 Lhs, float Rhs);
float4 DFDemote(FDFVector4 In);
struct FDFVector4
{
	float4 High;
	float4 Low;
	float4 Demote() { return DFDemote(this); }
};
FDFScalar DFGetComponent(FDFVector4 V, int C) { return MakeDFScalar(V.High[C], V.Low[C]); }
FDFVector4 MakeDFVector4(float4 High, float4 Low)
{
	FDFVector4 Result;
	Result.High = High;
	Result.Low = Low;
	return Result;
}
FDFVector4 DFPromote(FDFVector4 Value) { return Value; }
FDFVector4 DFPromote(float4 Value) { return MakeDFVector4(Value, (float4)0); }
float4 DFDemote(FDFVector4 Value) { return Value.High + Value.Low; }
float4 DFDemote(float4 Value) { return Value; }
FDFVector4 DFNegate(FDFVector4 Value)
{
	return MakeDFVector4(-Value.High, -Value.Low);
}
FDFVector4 DFTwoSum(float4 Lhs, float4 Rhs)
{
	const float4 S =   MakePrecise( ( Lhs ) + ( Rhs ) );
	const float4 V =   MakePrecise( ( S ) - ( Lhs ) );
	const float4 Q =   MakePrecise( ( S ) - ( V ) );
	const float4 R =   MakePrecise( ( Lhs ) - ( Q ) );
	const float4 T =   MakePrecise( ( Rhs ) - ( V ) );
	const float4 Y =   MakePrecise( ( R ) + ( T ) );
	return MakeDFVector4(S, Y);
}
FDFVector4 DFFastTwoSum(float4 Lhs, float4 Rhs)
{
	const float4 S =   MakePrecise( ( Lhs ) + ( Rhs ) );
	const float4 T =   MakePrecise( ( S ) - ( Lhs ) );
	const float4 E =   MakePrecise( ( Rhs ) - ( T ) );
	return MakeDFVector4(S, E);
}
FDFVector4 DFAdd(float4 Lhs, float4 Rhs) { return DFTwoSum(Lhs, Rhs); }
FDFVector4 DFAdd(FDFVector4 Lhs, FDFVector4 Rhs)
{
	FDFVector4 S = DFTwoSum(Lhs.High, Rhs.High);
	const FDFVector4 T = DFTwoSum(Lhs.Low, Rhs.Low);
	S.Low += T.High;
	S = DFFastTwoSum(S.High, S.Low);
	S.Low += T.Low;
	S = DFFastTwoSum(S.High, S.Low);
	return S;
}
FDFVector4 DFAdd(FDFVector4 Lhs, float4 Rhs)
{
	const FDFVector4 S = DFTwoSum(Lhs.High, Rhs);
	const float4 T = Lhs.Low + S.Low;
	return DFFastTwoSum(S.High, T);
}
FDFVector4 DFAdd(float4 Lhs, FDFVector4 Rhs) { return DFAdd(Rhs, Lhs); }
FDFVector4 DFSubtract(float4 Lhs, float4 Rhs) { return DFAdd(Lhs, -Rhs); }
FDFVector4 DFSubtract(FDFVector4 Lhs, FDFVector4 Rhs) { return DFAdd(Lhs, DFNegate(Rhs)); }
FDFVector4 DFSubtract(FDFVector4 Lhs, float4 Rhs) { return DFAdd(Lhs, -Rhs); }
FDFVector4 DFSubtract(float4 Lhs, FDFVector4 Rhs) { return DFAdd(Lhs, DFNegate(Rhs)); }
float4 DFFastLocalSubtractDemote(FDFVector4 Lhs, FDFVector4 Rhs)
{
	const float4 High =   MakePrecise( ( Lhs.High ) - ( Rhs.High ) );
	const float4 Low =   MakePrecise( ( Lhs.Low ) - ( Rhs.Low ) );
	const float4 Sum =   MakePrecise( ( High ) + ( Low ) );
	return Sum;
}
float4 DFFastLocalSubtractDemote(FDFVector4 Lhs, float4 Rhs)
{
	const float4 High =   MakePrecise( ( Lhs.High ) - ( Rhs ) );
	const float4 Sum =   MakePrecise( ( High ) + ( Lhs.Low ) );
	return Sum;
}
float4 DFFastLocalSubtractDemote(float4 Lhs, FDFVector4 Rhs)
{
	return DFFastLocalSubtractDemote(DFPromote(Lhs), Rhs);
}
FDFVector4 DFTwoProduct(float4 Lhs, float4 Rhs)
{
	const float4 P = Lhs * Rhs;
	const float4 E =   MakePrecise(  mad( ( Lhs ) , ( Rhs ) , ( -P ) ) );
	return MakeDFVector4(P, E);
}
FDFVector4 DFMultiply(float4 Lhs, float4 Rhs) { return DFTwoProduct(Lhs, Rhs); }
FDFVector4 DFMultiply(FDFVector4 Lhs, FDFVector4 Rhs)
{
	const FDFVector4 P = DFTwoProduct(Lhs.High, Rhs.High);
	float4 T =   MakePrecise( ( Lhs.High ) * ( Rhs.Low ) );
	T =   MakePrecise(  mad( ( Lhs.Low ) , ( Rhs.High ) , ( T ) ) );
	T =   MakePrecise( ( T ) + ( P.Low ) );
	return DFFastTwoSum(P.High, T);
}
FDFVector4 DFMultiply(FDFVector4 Lhs, float4 Rhs)
{
	FDFVector4 P = DFTwoProduct(Lhs.High, Rhs);
	float4 T =   MakePrecise(  mad( ( Lhs.Low ) , ( Rhs ) , ( P.Low ) ) );
	return DFFastTwoSum(P.High, T);
}
FDFVector4 DFMultiply(float4 Lhs, FDFVector4 Rhs) { return DFMultiply(Rhs, Lhs); }
FDFVector4 DFFastDivide(FDFVector4 Lhs, FDFVector4 Rhs);
FDFVector4 DFDivide(FDFVector4 Lhs, FDFVector4 Rhs)
{
	const float4 Th =   MakePrecise( ( 1.0 ) / ( Rhs.High ) );
	const float4 Rh =   MakePrecise(  mad( ( -Rhs.High ) , ( Th ) , ( (float4)1 ) ) );
	const float4 Rl =   MakePrecise( ( -Rhs.Low ) * ( Th ) );
	const FDFVector4 E = DFFastTwoSum(Rh, Rl);
	const FDFVector4 D = DFMultiply(E, Th);
	const FDFVector4 M = DFAdd(D, Th);
	return DFMultiply(Lhs, M);
}
FDFVector4 DFDivide(FDFVector4 Lhs, float4 Rhs)
{
	const float4 Th =   MakePrecise( ( Lhs.High ) / ( Rhs ) );
	const FDFVector4 P = DFTwoProduct(Th, Rhs);
	const float4 Dh =   MakePrecise( ( Lhs.High ) - ( P.High ) );
	const float4 Dt =   MakePrecise( ( Dh ) - ( P.Low ) );
	const float4 D =   MakePrecise( ( Dt ) + ( Lhs.Low ) );
	const float4 Tl =   MakePrecise( ( D ) / ( Rhs ) );
	return DFFastTwoSum(Th, Tl);
}
FDFVector4 DFDivide(float4 Lhs, float4 Rhs)
{
	return DFDivide(DFPromote(Lhs), Rhs);
}
FDFVector4 DFDivide(float4 Lhs, FDFVector4 Rhs)
{
	return DFDivide(DFPromote(Lhs), Rhs);
}
FDFVector4 DFFastDivide(FDFVector4 Lhs, FDFVector4 Rhs)
{
	const float4 Th =   MakePrecise( ( Lhs.High ) / ( Rhs.High ) );
	const FDFVector4 R = DFMultiply(Rhs, Th);
	const float4 Ph =   MakePrecise( ( Lhs.High ) - ( R.High ) );
	const float4 Dl =   MakePrecise( ( Lhs.Low ) - ( R.Low ) );
	const float4 D =   MakePrecise( ( Ph ) + ( Dl ) );
	const float4 Tl =   MakePrecise( ( D ) / ( Rhs.High ) );
	return DFFastTwoSum(Th, Tl);
}
FDFVector4 DFFastDivide(FDFVector4 Lhs, float4 Rhs)
{
	const float4 Th =   MakePrecise( ( Lhs.High ) / ( Rhs ) );
	const FDFVector4 R = DFTwoProduct(Rhs, Th);
	const float4 Ph =   MakePrecise( ( Lhs.High ) - ( R.High ) );
	const float4 Dl =   MakePrecise( ( Lhs.Low ) - ( R.Low ) );
	const float4 D =   MakePrecise( ( Ph ) + ( Dl ) );
	const float4 Tl =   MakePrecise( ( D ) / ( Rhs ) );
	return DFFastTwoSum(Th, Tl);
}
FDFVector4 DFFastDivide(float4 Lhs, FDFVector4 Rhs) { return DFFastDivide(DFPromote(Lhs), Rhs); }
FDFVector4 DFFastDivide(float4 Lhs, float4 Rhs) { return DFFastDivide(DFPromote(Lhs), Rhs); }
FDFVector4 DFBroadcast4(FDFScalar V)
{
	const float4 High = V.High;
	const float4 Low = V.Low;
	return MakeDFVector4(High, Low);
}
float4 DFBroadcast4(float V)
{
	const float4 Single = V;
	return Single;
}
FDFVector4  DFAdd (FDFScalar Lhs, FDFVector4 Rhs) { return DFAdd (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFAdd (float Lhs, FDFVector4 Rhs) { return DFAdd (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFAdd (FDFScalar Lhs, float4 Rhs) { return DFAdd (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFAdd (float Lhs, float4 Rhs) { return DFAdd (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFAdd (FDFVector4 Lhs, FDFScalar Rhs) { return DFAdd (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFAdd (FDFVector4 Lhs, float Rhs)     { return DFAdd (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFAdd (float4 Lhs, FDFScalar Rhs) { return DFAdd (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFAdd (float4 Lhs, float Rhs) { return DFAdd (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFSubtract (FDFScalar Lhs, FDFVector4 Rhs) { return DFSubtract (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFSubtract (float Lhs, FDFVector4 Rhs) { return DFSubtract (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFSubtract (FDFScalar Lhs, float4 Rhs) { return DFSubtract (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFSubtract (float Lhs, float4 Rhs) { return DFSubtract (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFSubtract (FDFVector4 Lhs, FDFScalar Rhs) { return DFSubtract (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFSubtract (FDFVector4 Lhs, float Rhs)     { return DFSubtract (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFSubtract (float4 Lhs, FDFScalar Rhs) { return DFSubtract (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFSubtract (float4 Lhs, float Rhs) { return DFSubtract (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFMultiply (FDFScalar Lhs, FDFVector4 Rhs) { return DFMultiply (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFMultiply (float Lhs, FDFVector4 Rhs) { return DFMultiply (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFMultiply (FDFScalar Lhs, float4 Rhs) { return DFMultiply (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFMultiply (float Lhs, float4 Rhs) { return DFMultiply (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFMultiply (FDFVector4 Lhs, FDFScalar Rhs) { return DFMultiply (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFMultiply (FDFVector4 Lhs, float Rhs)     { return DFMultiply (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFMultiply (float4 Lhs, FDFScalar Rhs) { return DFMultiply (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFMultiply (float4 Lhs, float Rhs) { return DFMultiply (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFDivide (FDFScalar Lhs, FDFVector4 Rhs) { return DFDivide (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFDivide (float Lhs, FDFVector4 Rhs) { return DFDivide (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFDivide (FDFScalar Lhs, float4 Rhs) { return DFDivide (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFDivide (float Lhs, float4 Rhs) { return DFDivide (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFDivide (FDFVector4 Lhs, FDFScalar Rhs) { return DFDivide (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFDivide (FDFVector4 Lhs, float Rhs)     { return DFDivide (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFDivide (float4 Lhs, FDFScalar Rhs) { return DFDivide (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFDivide (float4 Lhs, float Rhs) { return DFDivide (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFFastDivide (FDFScalar Lhs, FDFVector4 Rhs) { return DFFastDivide (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFFastDivide (float Lhs, FDFVector4 Rhs) { return DFFastDivide (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFFastDivide (FDFScalar Lhs, float4 Rhs) { return DFFastDivide (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFFastDivide (float Lhs, float4 Rhs) { return DFFastDivide (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFFastDivide (FDFVector4 Lhs, FDFScalar Rhs) { return DFFastDivide (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFFastDivide (FDFVector4 Lhs, float Rhs)     { return DFFastDivide (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFFastDivide (float4 Lhs, FDFScalar Rhs) { return DFFastDivide (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFFastDivide (float4 Lhs, float Rhs) { return DFFastDivide (Lhs, DFBroadcast4(Rhs)); }
struct FDFMatrix
{
	float4x4 M;
	float3 PostTranslation; 
};
float4x4 MakeTranslationMatrix(float3 Offset)
{
	float4x4 Result;
	Result[0] = float4(1.0f, 0.0f, 0.0f, 0.0f);
	Result[1] = float4(0.0f, 1.0f, 0.0f, 0.0f);
	Result[2] = float4(0.0f, 0.0f, 1.0f, 0.0f);
	Result[3] = float4(Offset, 1.0f);
	return Result;
}
FDFMatrix MakeDFMatrix(float3 PostTranslation, float4x4 InMatrix)
{
	FDFMatrix Result;
	Result.PostTranslation = PostTranslation;
	Result.M = InMatrix;
	return Result;
}
struct FDFInverseMatrix
{
	float4x4 M;
	float3 PreTranslation; 
};
FDFInverseMatrix MakeDFInverseMatrix(float3 PreTranslation, float4x4 InMatrix)
{
	FDFInverseMatrix Result;
	Result.PreTranslation = PreTranslation;
	Result.M = InMatrix;
	return Result;
}
FDFVector3 DFMultiply(float3 Vector, FDFMatrix InMatrix)
{
	float4 Result = mul(float4(Vector, 1), InMatrix.M);
	FDFVector3 V = DFTwoSum(InMatrix.PostTranslation, Result.xyz);
	return V;
}
FDFVector4 DFMultiply(float4 Vector, FDFMatrix InMatrix)
{
	float4 Result = mul(Vector, InMatrix.M);
	FDFVector4 V = DFTwoSum(float4(InMatrix.PostTranslation, 0), Result);
	return V;
}
FDFInverseMatrix DFMultiply(FDFInverseMatrix Lhs, float4x4 Rhs)
{
	float4x4 M = mul(Lhs.M, Rhs);
	float3 PreTranslation = Lhs.PreTranslation;
	return MakeDFInverseMatrix(PreTranslation, M);
}
FDFMatrix DFMultiply(float4x4 Lhs, FDFMatrix Rhs)
{
	float4x4 M = mul(Lhs, Rhs.M);
	float3 PostTranslation = Rhs.PostTranslation;
	return MakeDFMatrix(PostTranslation, M);
}
float4x4 MultiplyTranslation(float4x4 M, float3 Translation)
{
	float4x4 Result = M;
	Result[3].xyz += Translation;
	return Result;
}
float4x4 MultiplyTranslation(float3 Translation, float4x4 M)
{
	return mul(MakeTranslationMatrix(Translation), M);
}
FDFMatrix DFPromote(FDFMatrix Value) { return Value; }
FDFMatrix  DFPromote(float4x4 Value) { return MakeDFMatrix((float3)0, Value); }
float4x4 DFDemote(FDFMatrix V)
{
	return MultiplyTranslation(V.M, V.PostTranslation);
}
float4x4 DFDemote(float4x4 V)
{
	return V;
}
float4x4 DFDemote(FDFInverseMatrix V)
{
	return MultiplyTranslation(-V.PreTranslation, V.M);
}
FDFMatrix WaveReadLaneAt(FDFMatrix In, uint SrcIndex)
{
	FDFMatrix Result;
	Result.M[0] = WaveReadLaneAt(In.M[0], SrcIndex);
	Result.M[1] = WaveReadLaneAt(In.M[1], SrcIndex);
	Result.M[2] = WaveReadLaneAt(In.M[2], SrcIndex);
	Result.M[3] = WaveReadLaneAt(In.M[3], SrcIndex);
	Result.PostTranslation = WaveReadLaneAt(In.PostTranslation, SrcIndex);
	return Result;
}
FDFInverseMatrix WaveReadLaneAt(FDFInverseMatrix In, uint SrcIndex)
{
	FDFInverseMatrix Result;
	Result.M[0] = WaveReadLaneAt(In.M[0], SrcIndex);
	Result.M[1] = WaveReadLaneAt(In.M[1], SrcIndex);
	Result.M[2] = WaveReadLaneAt(In.M[2], SrcIndex);
	Result.M[3] = WaveReadLaneAt(In.M[3], SrcIndex);
	Result.PreTranslation = WaveReadLaneAt(In.PreTranslation, SrcIndex);
	return Result;
}
struct FLWCVector3
{
	float3 Tile;
	float3 Offset;
};
struct FLWCMatrix
{
	float4x4 M;
	float3 Tile; 
};
struct FLWCInverseMatrix
{
	float4x4 M;
	float3 Tile; 
};
FLWCVector3 MakeLWCVector3(float3 Tile, float3 Offset)
{
	FLWCVector3 Result;
	 ( Result ).Tile = ( Tile );
	Result.Offset = Offset;
	return Result;
}
FLWCMatrix WaveReadLaneAt(FLWCMatrix In, uint SrcIndex)
{
	FLWCMatrix Result;
	Result.M[0] = WaveReadLaneAt(In.M[0], SrcIndex);
	Result.M[1] = WaveReadLaneAt(In.M[1], SrcIndex);
	Result.M[2] = WaveReadLaneAt(In.M[2], SrcIndex);
	Result.M[3] = WaveReadLaneAt(In.M[3], SrcIndex);
	Result.Tile = WaveReadLaneAt(In.Tile, SrcIndex);
	return Result;
}
FLWCInverseMatrix WaveReadLaneAt(FLWCInverseMatrix In, uint SrcIndex)
{
	FLWCInverseMatrix Result;
	Result.M[0] = WaveReadLaneAt(In.M[0], SrcIndex);
	Result.M[1] = WaveReadLaneAt(In.M[1], SrcIndex);
	Result.M[2] = WaveReadLaneAt(In.M[2], SrcIndex);
	Result.M[3] = WaveReadLaneAt(In.M[3], SrcIndex);
	Result.Tile = WaveReadLaneAt(In.Tile, SrcIndex);
	return Result;
}
struct FViewConstants {
	 float4x4    TranslatedWorldToClip ;
	 float4x4    RelativeWorldToClip ;
	 float4x4    ClipToRelativeWorld ;
	 float4x4    TranslatedWorldToView ;
	 float4x4    ViewToTranslatedWorld ;
	 float4x4    TranslatedWorldToCameraView ;
	 float4x4    CameraViewToTranslatedWorld ;
	 float4x4    ViewToClip ;
	 float4x4    ViewToClipNoAA ;
	 float4x4    ClipToView ;
	 float4x4    ClipToTranslatedWorld ;
	 float4x4    SVPositionToTranslatedWorld ;
	 float4x4    ScreenToRelativeWorld ;
	 float4x4    ScreenToTranslatedWorld ;
	 float4x4    MobileMultiviewShadowTransform ;
	 float3    ViewOriginHigh ;
	 float    Padding972 ;
	 float3    ViewForward ;
	 float    Padding988 ;
	 float3    ViewUp ;
	 float    Padding1004 ;
	 float3    ViewRight ;
	 float    Padding1020 ;
	 float3    HMDViewNoRollUp ;
	 float    Padding1036 ;
	 float3    HMDViewNoRollRight ;
	 float    Padding1052 ;
	 float4    InvDeviceZToWorldZTransform ;
	 float4    ScreenPositionScaleBias ;
	 float3    ViewOriginLow ;
	 float    Padding1100 ;
	 float3    TranslatedWorldCameraOrigin ;
	 float    Padding1116 ;
	 float3    WorldViewOriginHigh ;
	 float    Padding1132 ;
	 float3    WorldViewOriginLow ;
	 float    Padding1148 ;
	 float3    PreViewTranslationHigh ;
	 float    Padding1164 ;
	 float3    PreViewTranslationLow ;
	 float    Padding1180 ;
	 float4x4    PrevViewToClip ;
	 float4x4    PrevClipToView ;
	 float4x4    PrevTranslatedWorldToClip ;
	 float4x4    PrevTranslatedWorldToView ;
	 float4x4    PrevViewToTranslatedWorld ;
	 float4x4    PrevTranslatedWorldToCameraView ;
	 float4x4    PrevCameraViewToTranslatedWorld ;
	 float3    PrevTranslatedWorldCameraOrigin ;
	 float    Padding1644 ;
	 float3    PrevWorldCameraOriginHigh ;
	 float    Padding1660 ;
	 float3    PrevWorldCameraOriginLow ;
	 float    Padding1676 ;
	 float3    PrevWorldViewOriginHigh ;
	 float    Padding1692 ;
	 float3    PrevWorldViewOriginLow ;
	 float    Padding1708 ;
	 float3    PrevPreViewTranslationHigh ;
	 float    Padding1724 ;
	 float3    PrevPreViewTranslationLow ;
	 float    Padding1740 ;
	 float3    ViewTilePosition ;
	 float    Padding1756 ;
	 float3    RelativeWorldCameraOriginTO ;
	 float    Padding1772 ;
	 float3    RelativeWorldViewOriginTO ;
	 float    Padding1788 ;
	 float3    RelativePreViewTranslationTO ;
	 float    Padding1804 ;
	 float3    PrevRelativeWorldCameraOriginTO ;
	 float    Padding1820 ;
	 float3    PrevRelativeWorldViewOriginTO ;
	 float    Padding1836 ;
	 float3    RelativePrevPreViewTranslationTO ;
	 float    Padding1852 ;
	 float4x4    PrevClipToRelativeWorld ;
	 float4x4    PrevScreenToTranslatedWorld ;
	 float4x4    ClipToPrevClip ;
	 float4x4    ClipToPrevClipWithAA ;
	 float4    TemporalAAJitter ;
	 float4    GlobalClippingPlane ;
	 float2    FieldOfViewWideAngles ;
	 float2    PrevFieldOfViewWideAngles ;
	 float4    ViewRectMin ;
	 float4    ViewSizeAndInvSize ;
	 uint4    ViewRectMinAndSize ;
	 float4    LightProbeSizeRatioAndInvSizeRatio ;
	 float4    BufferSizeAndInvSize ;
	 float4    BufferBilinearUVMinMax ;
	 float4    ScreenToViewSpace ;
	 float2    BufferToSceneTextureScale ;
	 float2    ResolutionFractionAndInv ;
	 int    NumSceneColorMSAASamples ;
	 float    ProjectionDepthThicknessScale ;
	 float    PreExposure ;
	 float    OneOverPreExposure ;
	 float4    DiffuseOverrideParameter ;
	 float4    SpecularOverrideParameter ;
	 float4    NormalOverrideParameter ;
	 float2    RoughnessOverrideParameter ;
	 float    PrevFrameGameTime ;
	 float    PrevFrameRealTime ;
	 float    OutOfBoundsMask ;
	 float    Padding2372 ;
	 float    Padding2376 ;
	 float    Padding2380 ;
	 float3    WorldCameraMovementSinceLastFrame ;
	 float    CullingSign ;
	 float    NearPlane ;
	 float    GameTime ;
	 float    RealTime ;
	 float    DeltaTime ;
	 float    MaterialTextureMipBias ;
	 float    MaterialTextureDerivativeMultiply ;
	 uint    Random ;
	 uint    FrameNumber ;
	 uint    FrameCounter ;
	 uint    StateFrameIndexMod8 ;
	 uint    StateFrameIndex ;
	 uint    DebugViewModeMask ;
	 uint    WorldIsPaused ;
	 float    CameraCut ;
	 float    UnlitViewmodeMask ;
	 float    Padding2460 ;
	 float4    DirectionalLightColor ;
	 float3    DirectionalLightDirection ;
	 float    Padding2492 ;
	 float4    TranslucencyLightingVolumeMin[2] ;
	 float4    TranslucencyLightingVolumeInvSize[2] ;
	 float4    TemporalAAParams ;
	 float4    CircleDOFParams ;
	 float    DepthOfFieldSensorWidth ;
	 float    DepthOfFieldFocalDistance ;
	 float    DepthOfFieldScale ;
	 float    DepthOfFieldFocalLength ;
	 float    DepthOfFieldFocalRegion ;
	 float    DepthOfFieldNearTransitionRegion ;
	 float    DepthOfFieldFarTransitionRegion ;
	 float    MotionBlurNormalizedToPixel ;
	 float    GeneralPurposeTweak ;
	 float    GeneralPurposeTweak2 ;
	 float    DemosaicVposOffset ;
	 float    DecalDepthBias ;
	 float3    IndirectLightingColorScale ;
	 float    Padding2652 ;
	 float3    PrecomputedIndirectLightingColorScale ;
	 float    Padding2668 ;
	 float3    PrecomputedIndirectSpecularColorScale ;
	 float    Padding2684 ;
	 float4    AtmosphereLightDirection[2] ;
	 float4    AtmosphereLightIlluminanceOnGroundPostTransmittance[2] ;
	 float4    AtmosphereLightIlluminanceOuterSpace[2] ;
	 float4    AtmosphereLightDiscLuminance[2] ;
	 float4    AtmosphereLightDiscCosHalfApexAngle_PPTrans[2] ;
	 float4    SkyViewLutSizeAndInvSize ;
	 float3    SkyCameraTranslatedWorldOrigin ;
	 float    Padding2876 ;
	 float4    SkyPlanetTranslatedWorldCenterAndViewHeight ;
	 float4x4    SkyViewLutReferential ;
	 float4    SkyAtmosphereSkyLuminanceFactor ;
	 float    SkyAtmospherePresentInScene ;
	 float    SkyAtmosphereHeightFogContribution ;
	 float    SkyAtmosphereBottomRadiusKm ;
	 float    SkyAtmosphereTopRadiusKm ;
	 float4    SkyAtmosphereCameraAerialPerspectiveVolumeSizeAndInvSize ;
	 float    SkyAtmosphereAerialPerspectiveStartDepthKm ;
	 float    SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolution ;
	 float    SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv ;
	 float    SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm ;
	 float    SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKmInv ;
	 float    SkyAtmosphereApplyCameraAerialPerspectiveVolume ;
	 float    Padding3032 ;
	 float    Padding3036 ;
	 float3    NormalCurvatureToRoughnessScaleBias ;
	 float    RenderingReflectionCaptureMask ;
	 float    RealTimeReflectionCapture ;
	 float    RealTimeReflectionCapturePreExposure ;
	 float    Padding3064 ;
	 float    Padding3068 ;
	 float4    AmbientCubemapTint ;
	 float    AmbientCubemapIntensity ;
	 float    SkyLightApplyPrecomputedBentNormalShadowingFlag ;
	 float    SkyLightAffectReflectionFlag ;
	 float    SkyLightAffectGlobalIlluminationFlag ;
	 float4    SkyLightColor ;
	 float    SkyLightVolumetricScatteringIntensity ;
	 float    Padding3124 ;
	 float    Padding3128 ;
	 float    Padding3132 ;
	 float4    MobileSkyIrradianceEnvironmentMap[8] ;
	 float    MobilePreviewMode ;
	 float    HMDEyePaddingOffset ;
	 float    ReflectionCubemapMaxMip ;
	 float    ShowDecalsMask ;
	 uint    DistanceFieldAOSpecularOcclusionMode ;
	 float    IndirectCapsuleSelfShadowingIntensity ;
	 float    Padding3288 ;
	 float    Padding3292 ;
	 float3    ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight ;
	 int    StereoPassIndex ;
	 float4    GlobalVolumeTranslatedCenterAndExtent[6] ;
	 float4    GlobalVolumeTranslatedWorldToUVAddAndMul[6] ;
	 float4    GlobalDistanceFieldMipTranslatedWorldToUVScale[6] ;
	 float4    GlobalDistanceFieldMipTranslatedWorldToUVBias[6] ;
	 float    GlobalDistanceFieldMipFactor ;
	 float    GlobalDistanceFieldMipTransition ;
	 int    GlobalDistanceFieldClipmapSizeInPages ;
	 int    Padding3708 ;
	 float3    GlobalDistanceFieldInvPageAtlasSize ;
	 float    Padding3724 ;
	 float3    GlobalDistanceFieldInvCoverageAtlasSize ;
	 float    GlobalVolumeDimension ;
	 float    GlobalVolumeTexelSize ;
	 float    MaxGlobalDFAOConeDistance ;
	 uint    NumGlobalSDFClipmaps ;
	 float    CoveredExpandSurfaceScale ;
	 float    NotCoveredExpandSurfaceScale ;
	 float    NotCoveredMinStepScale ;
	 float    DitheredTransparencyStepThreshold ;
	 float    DitheredTransparencyTraceThreshold ;
	 int2    CursorPosition ;
	 float    bCheckerboardSubsurfaceProfileRendering ;
	 float    Padding3788 ;
	 float3    VolumetricFogInvGridSize ;
	 float    Padding3804 ;
	 float3    VolumetricFogGridZParams ;
	 float    Padding3820 ;
	 float2    VolumetricFogSVPosToVolumeUV ;
	 float2    VolumetricFogViewGridUVToPrevViewRectUV ;
	 float2    VolumetricFogPrevViewGridRectUVToResourceUV ;
	 float2    VolumetricFogPrevUVMax ;
	 float2    VolumetricFogPrevUVMaxForTemporalBlend ;
	 float2    VolumetricFogScreenToResourceUV ;
	 float2    VolumetricFogUVMax ;
	 float    VolumetricFogMaxDistance ;
	 float    Padding3884 ;
	 float3    VolumetricLightmapWorldToUVScale ;
	 float    Padding3900 ;
	 float3    VolumetricLightmapWorldToUVAdd ;
	 float    Padding3916 ;
	 float3    VolumetricLightmapIndirectionTextureSize ;
	 float    VolumetricLightmapBrickSize ;
	 float3    VolumetricLightmapBrickTexelSize ;
	 float    IndirectLightingCacheShowFlag ;
	 float    EyeToPixelSpreadAngle ;
	 float    Padding3956 ;
	 float    Padding3960 ;
	 float    Padding3964 ;
	 float4    XRPassthroughCameraUVs[2] ;
	 float    GlobalVirtualTextureMipBias ;
	 uint    VirtualTextureFeedbackShift ;
	 uint    VirtualTextureFeedbackMask ;
	 uint    VirtualTextureFeedbackStride ;
	 uint    VirtualTextureFeedbackJitterOffset ;
	 uint    VirtualTextureFeedbackSampleOffset ;
	 uint    Padding4024 ;
	 uint    Padding4028 ;
	 float4    RuntimeVirtualTextureMipLevel ;
	 float2    RuntimeVirtualTexturePackHeight ;
	 float    Padding4056 ;
	 float    Padding4060 ;
	 float4    RuntimeVirtualTextureDebugParams ;
	 int    FarShadowStaticMeshLODBias ;
	 float    MinRoughness ;
	 float    Padding4088 ;
	 float    Padding4092 ;
	 float4    HairRenderInfo ;
	 uint    EnableSkyLight ;
	 uint    HairRenderInfoBits ;
	 uint    HairComponents ;
	 float    bSubsurfacePostprocessEnabled ;
	 float4    SSProfilesTextureSizeAndInvSize ;
	 float4    SSProfilesPreIntegratedTextureSizeAndInvSize ;
	 float4    SpecularProfileTextureSizeAndInvSize ;
	 float3    PhysicsFieldClipmapCenter ;
	 float    PhysicsFieldClipmapDistance ;
	 int    PhysicsFieldClipmapResolution ;
	 int    PhysicsFieldClipmapExponent ;
	 int    PhysicsFieldClipmapCount ;
	 int    PhysicsFieldTargetCount ;
	 int4    PhysicsFieldTargets[32] ;
	 uint    GPUSceneViewId ;
	 float    ViewResolutionFraction ;
	 float    SubSurfaceColorAsTransmittanceAtDistanceInMeters ;
	 float    Padding4732 ;
	 float4    TanAndInvTanHalfFOV ;
	 float4    PrevTanAndInvTanHalfFOV ;
	 float2    WorldDepthToPixelWorldRadius ;
	 float    Padding4776 ;
	 float    Padding4780 ;
	 float4    ScreenRayLengthMultiplier ;
	 float4    GlintLUTParameters0 ;
	 float4    GlintLUTParameters1 ;
	 int4    EnvironmentComponentsFlags ;
	 uint    BindlessSampler_MaterialTextureBilinearWrapedSampler ;
	 uint    Padding4852 ;
	 uint    BindlessSampler_MaterialTextureBilinearClampedSampler ;
	 uint    Padding4860 ;
	 uint    BindlessSRV_VolumetricLightmapIndirectionTexture ;
	 uint    Padding4868 ;
	 uint    BindlessSRV_VolumetricLightmapBrickAmbientVector ;
	 uint    Padding4876 ;
	 uint    BindlessSRV_VolumetricLightmapBrickSHCoefficients0 ;
	 uint    Padding4884 ;
	 uint    BindlessSRV_VolumetricLightmapBrickSHCoefficients1 ;
	 uint    Padding4892 ;
	 uint    BindlessSRV_VolumetricLightmapBrickSHCoefficients2 ;
	 uint    Padding4900 ;
	 uint    BindlessSRV_VolumetricLightmapBrickSHCoefficients3 ;
	 uint    Padding4908 ;
	 uint    BindlessSRV_VolumetricLightmapBrickSHCoefficients4 ;
	 uint    Padding4916 ;
	 uint    BindlessSRV_VolumetricLightmapBrickSHCoefficients5 ;
	 uint    Padding4924 ;
	 uint    BindlessSRV_SkyBentNormalBrickTexture ;
	 uint    Padding4932 ;
	 uint    BindlessSRV_DirectionalLightShadowingBrickTexture ;
	 uint    Padding4940 ;
	 uint    BindlessSampler_VolumetricLightmapBrickAmbientVectorSampler ;
	 uint    Padding4948 ;
	 uint    BindlessSampler_VolumetricLightmapTextureSampler0 ;
	 uint    Padding4956 ;
	 uint    BindlessSampler_VolumetricLightmapTextureSampler1 ;
	 uint    Padding4964 ;
	 uint    BindlessSampler_VolumetricLightmapTextureSampler2 ;
	 uint    Padding4972 ;
	 uint    BindlessSampler_VolumetricLightmapTextureSampler3 ;
	 uint    Padding4980 ;
	 uint    BindlessSampler_VolumetricLightmapTextureSampler4 ;
	 uint    Padding4988 ;
	 uint    BindlessSampler_VolumetricLightmapTextureSampler5 ;
	 uint    Padding4996 ;
	 uint    BindlessSampler_SkyBentNormalTextureSampler ;
	 uint    Padding5004 ;
	 uint    BindlessSampler_DirectionalLightShadowingTextureSampler ;
	 uint    Padding5012 ;
	 uint    BindlessSRV_GlobalDistanceFieldPageAtlasTexture ;
	 uint    Padding5020 ;
	 uint    BindlessSRV_GlobalDistanceFieldCoverageAtlasTexture ;
	 uint    Padding5028 ;
	 uint    BindlessSRV_GlobalDistanceFieldPageTableTexture ;
	 uint    Padding5036 ;
	 uint    BindlessSRV_GlobalDistanceFieldMipTexture ;
	 uint    Padding5044 ;
	 uint    BindlessSampler_GlobalDistanceFieldPageAtlasTextureSampler ;
	 uint    Padding5052 ;
	 uint    BindlessSampler_GlobalDistanceFieldCoverageAtlasTextureSampler ;
	 uint    Padding5060 ;
	 uint    BindlessSampler_GlobalDistanceFieldMipTextureSampler ;
	 uint    Padding5068 ;
	 uint    BindlessSRV_AtmosphereTransmittanceTexture ;
	 uint    Padding5076 ;
	 uint    BindlessSampler_AtmosphereTransmittanceTextureSampler ;
	 uint    Padding5084 ;
	 uint    BindlessSRV_AtmosphereIrradianceTexture ;
	 uint    Padding5092 ;
	 uint    BindlessSampler_AtmosphereIrradianceTextureSampler ;
	 uint    Padding5100 ;
	 uint    BindlessSRV_AtmosphereInscatterTexture ;
	 uint    Padding5108 ;
	 uint    BindlessSampler_AtmosphereInscatterTextureSampler ;
	 uint    Padding5116 ;
	 uint    BindlessSRV_PerlinNoiseGradientTexture ;
	 uint    Padding5124 ;
	 uint    BindlessSampler_PerlinNoiseGradientTextureSampler ;
	 uint    Padding5132 ;
	 uint    BindlessSRV_PerlinNoise3DTexture ;
	 uint    Padding5140 ;
	 uint    BindlessSampler_PerlinNoise3DTextureSampler ;
	 uint    Padding5148 ;
	 uint    BindlessSRV_SobolSamplingTexture ;
	 uint    Padding5156 ;
	 uint    BindlessSampler_SharedPointWrappedSampler ;
	 uint    Padding5164 ;
	 uint    BindlessSampler_SharedPointClampedSampler ;
	 uint    Padding5172 ;
	 uint    BindlessSampler_SharedBilinearWrappedSampler ;
	 uint    Padding5180 ;
	 uint    BindlessSampler_SharedBilinearClampedSampler ;
	 uint    Padding5188 ;
	 uint    BindlessSampler_SharedBilinearAnisoClampedSampler ;
	 uint    Padding5196 ;
	 uint    BindlessSampler_SharedTrilinearWrappedSampler ;
	 uint    Padding5204 ;
	 uint    BindlessSampler_SharedTrilinearClampedSampler ;
	 uint    Padding5212 ;
	 uint    BindlessSRV_PreIntegratedBRDF ;
	 uint    Padding5220 ;
	 uint    BindlessSampler_PreIntegratedBRDFSampler ;
	 uint    Padding5228 ;
	 uint    BindlessSRV_SkyIrradianceEnvironmentMap ;
	 uint    Padding5236 ;
	 uint    BindlessSRV_TransmittanceLutTexture ;
	 uint    Padding5244 ;
	 uint    BindlessSampler_TransmittanceLutTextureSampler ;
	 uint    Padding5252 ;
	 uint    BindlessSRV_SkyViewLutTexture ;
	 uint    Padding5260 ;
	 uint    BindlessSampler_SkyViewLutTextureSampler ;
	 uint    Padding5268 ;
	 uint    BindlessSRV_DistantSkyLightLutTexture ;
	 uint    Padding5276 ;
	 uint    BindlessSampler_DistantSkyLightLutTextureSampler ;
	 uint    Padding5284 ;
	 uint    BindlessSRV_CameraAerialPerspectiveVolume ;
	 uint    Padding5292 ;
	 uint    BindlessSampler_CameraAerialPerspectiveVolumeSampler ;
	 uint    Padding5300 ;
	 uint    BindlessSRV_CameraAerialPerspectiveVolumeMieOnly ;
	 uint    Padding5308 ;
	 uint    BindlessSampler_CameraAerialPerspectiveVolumeMieOnlySampler ;
	 uint    Padding5316 ;
	 uint    BindlessSRV_CameraAerialPerspectiveVolumeRayOnly ;
	 uint    Padding5324 ;
	 uint    BindlessSampler_CameraAerialPerspectiveVolumeRayOnlySampler ;
	 uint    Padding5332 ;
	 uint    BindlessSRV_HairScatteringLUTTexture ;
	 uint    Padding5340 ;
	 uint    BindlessSampler_HairScatteringLUTSampler ;
	 uint    Padding5348 ;
	 uint    BindlessSRV_GGXLTCMatTexture ;
	 uint    Padding5356 ;
	 uint    BindlessSampler_GGXLTCMatSampler ;
	 uint    Padding5364 ;
	 uint    BindlessSRV_GGXLTCAmpTexture ;
	 uint    Padding5372 ;
	 uint    BindlessSampler_GGXLTCAmpSampler ;
	 uint    Padding5380 ;
	 uint    BindlessSRV_SheenLTCTexture ;
	 uint    Padding5388 ;
	 uint    BindlessSampler_SheenLTCSampler ;
	 uint    Padding5396 ;
	 uint    bShadingEnergyConservation ;
	 uint    bShadingEnergyPreservation ;
	 uint    BindlessSRV_ShadingEnergyGGXSpecTexture ;
	 uint    Padding5412 ;
	 uint    BindlessSRV_ShadingEnergyGGXGlassTexture ;
	 uint    Padding5420 ;
	 uint    BindlessSRV_ShadingEnergyClothSpecTexture ;
	 uint    Padding5428 ;
	 uint    BindlessSRV_ShadingEnergyDiffuseTexture ;
	 uint    Padding5436 ;
	 uint    BindlessSampler_ShadingEnergySampler ;
	 uint    Padding5444 ;
	 uint    BindlessSRV_GlintTexture ;
	 uint    Padding5452 ;
	 uint    BindlessSampler_GlintSampler ;
	 uint    Padding5460 ;
	 uint    BindlessSRV_SimpleVolumeTexture ;
	 uint    Padding5468 ;
	 uint    BindlessSampler_SimpleVolumeTextureSampler ;
	 uint    Padding5476 ;
	 uint    BindlessSRV_SimpleVolumeEnvTexture ;
	 uint    Padding5484 ;
	 uint    BindlessSampler_SimpleVolumeEnvTextureSampler ;
	 uint    Padding5492 ;
	 uint    BindlessSRV_SSProfilesTexture ;
	 uint    Padding5500 ;
	 uint    BindlessSampler_SSProfilesSampler ;
	 uint    Padding5508 ;
	 uint    BindlessSampler_SSProfilesTransmissionSampler ;
	 uint    Padding5516 ;
	 uint    BindlessSRV_SSProfilesPreIntegratedTexture ;
	 uint    Padding5524 ;
	 uint    BindlessSampler_SSProfilesPreIntegratedSampler ;
	 uint    Padding5532 ;
	 uint    BindlessSRV_SpecularProfileTexture ;
	 uint    Padding5540 ;
	 uint    BindlessSampler_SpecularProfileSampler ;
	 uint    Padding5548 ;
	 uint    BindlessSRV_WaterIndirection ;
	 uint    Padding5556 ;
	 uint    BindlessSRV_WaterData ;
	 uint    Padding5564 ;
	 float4    RectLightAtlasSizeAndInvSize ;
	 float    RectLightAtlasMaxMipLevel ;
	 float    Padding5588 ;
	 uint    BindlessSRV_RectLightAtlasTexture ;
	 uint    Padding5596 ;
	 uint    BindlessSampler_RectLightAtlasSampler ;
	 uint    Padding5604 ;
	 uint    Padding5608 ;
	 uint    Padding5612 ;
	 float4    IESAtlasSizeAndInvSize ;
	 uint    BindlessSRV_IESAtlasTexture ;
	 uint    Padding5636 ;
	 uint    BindlessSampler_IESAtlasSampler ;
	 uint    Padding5644 ;
	 uint    BindlessSampler_LandscapeWeightmapSampler ;
	 uint    Padding5652 ;
	 uint    BindlessSRV_LandscapeIndirection ;
	 uint    Padding5660 ;
	 uint    BindlessSRV_LandscapePerComponentData ;
	 uint    Padding5668 ;
	 uint    BindlessUAV_VTFeedbackBuffer ;
	 uint    Padding5676 ;
	 uint    BindlessSRV_PhysicsFieldClipmapBuffer ;
	 uint    Padding5684 ;
	 uint    Padding5688 ;
	 uint    Padding5692 ;
	 float3    TLASPreViewTranslationHigh ;
	 float    Padding5708 ;
	 float3    TLASPreViewTranslationLow ;
 };
ConstantBuffer<FViewConstants> View;
struct ViewStateTileOffsetData
{
	FLWCVector3 WorldCameraOrigin;
	FLWCVector3 WorldViewOrigin;
	FLWCVector3 PrevWorldCameraOrigin;
	FLWCVector3 PrevWorldViewOrigin;
	FLWCVector3 PreViewTranslation;
	FLWCVector3 PrevPreViewTranslation;
};
struct ViewState
{
	float4x4 TranslatedWorldToClip;
	float4x4 RelativeWorldToClip;
	float4x4 ClipToRelativeWorld;
	float4x4 TranslatedWorldToView;
	float4x4 ViewToTranslatedWorld;
	float4x4 TranslatedWorldToCameraView;
	float4x4 CameraViewToTranslatedWorld;
	float4x4 ViewToClip;
	float4x4 ViewToClipNoAA;
	float4x4 ClipToView;
	float4x4 ClipToTranslatedWorld;
	float4x4 SVPositionToTranslatedWorld;
	float4x4 ScreenToRelativeWorld;
	float4x4 ScreenToTranslatedWorld;
	float4x4 MobileMultiviewShadowTransform;
	float3 ViewOriginHigh;
	float3 ViewForward;
	float3 ViewUp;
	float3 ViewRight;
	float3 HMDViewNoRollUp;
	float3 HMDViewNoRollRight;
	float4 InvDeviceZToWorldZTransform;
	float4 ScreenPositionScaleBias;
	float3 ViewOriginLow;
	float3 TranslatedWorldCameraOrigin;
	float3 WorldViewOriginHigh;
	float3 WorldViewOriginLow;
	float3 PreViewTranslationHigh;
	float3 PreViewTranslationLow;
	float4x4 PrevViewToClip;
	float4x4 PrevClipToView;
	float4x4 PrevTranslatedWorldToClip;
	float4x4 PrevTranslatedWorldToView;
	float4x4 PrevViewToTranslatedWorld;
	float4x4 PrevTranslatedWorldToCameraView;
	float4x4 PrevCameraViewToTranslatedWorld;
	float3 PrevTranslatedWorldCameraOrigin;
	float3 PrevWorldCameraOriginHigh;
	float3 PrevWorldCameraOriginLow;
	float3 PrevWorldViewOriginHigh;
	float3 PrevWorldViewOriginLow;
	float3 PrevPreViewTranslationHigh;
	float3 PrevPreViewTranslationLow;
	float3 ViewTilePosition;
	float3 RelativeWorldCameraOriginTO;
	float3 RelativeWorldViewOriginTO;
	float3 RelativePreViewTranslationTO;
	float3 PrevRelativeWorldCameraOriginTO;
	float3 PrevRelativeWorldViewOriginTO;
	float3 RelativePrevPreViewTranslationTO;
	float4x4 PrevClipToRelativeWorld;
	float4x4 PrevScreenToTranslatedWorld;
	float4x4 ClipToPrevClip;
	float4x4 ClipToPrevClipWithAA;
	float4 TemporalAAJitter;
	float4 GlobalClippingPlane;
	float2 FieldOfViewWideAngles;
	float2 PrevFieldOfViewWideAngles;
	float4 ViewRectMin;
	float4 ViewSizeAndInvSize;
	uint4 ViewRectMinAndSize;
	float4 LightProbeSizeRatioAndInvSizeRatio;
	float4 BufferSizeAndInvSize;
	float4 BufferBilinearUVMinMax;
	float4 ScreenToViewSpace;
	float2 BufferToSceneTextureScale;
	float2 ResolutionFractionAndInv;
	int NumSceneColorMSAASamples;
	float ProjectionDepthThicknessScale;
	float PreExposure;
	float OneOverPreExposure;
	float4 DiffuseOverrideParameter;
	float4 SpecularOverrideParameter;
	float4 NormalOverrideParameter;
	float2 RoughnessOverrideParameter;
	float PrevFrameGameTime;
	float PrevFrameRealTime;
	float OutOfBoundsMask;
	float3 WorldCameraMovementSinceLastFrame;
	float CullingSign;
	float NearPlane;
	float GameTime;
	float RealTime;
	float DeltaTime;
	float MaterialTextureMipBias;
	float MaterialTextureDerivativeMultiply;
	uint Random;
	uint FrameNumber;
	uint FrameCounter;
	uint StateFrameIndexMod8;
	uint StateFrameIndex;
	uint DebugViewModeMask;
	uint WorldIsPaused;
	float CameraCut;
	float UnlitViewmodeMask;
	float4 DirectionalLightColor;
	float3 DirectionalLightDirection;
	float4 TranslucencyLightingVolumeMin[2];
	float4 TranslucencyLightingVolumeInvSize[2];
	float4 TemporalAAParams;
	float4 CircleDOFParams;
	float DepthOfFieldSensorWidth;
	float DepthOfFieldFocalDistance;
	float DepthOfFieldScale;
	float DepthOfFieldFocalLength;
	float DepthOfFieldFocalRegion;
	float DepthOfFieldNearTransitionRegion;
	float DepthOfFieldFarTransitionRegion;
	float MotionBlurNormalizedToPixel;
	float GeneralPurposeTweak;
	float GeneralPurposeTweak2;
	float DemosaicVposOffset;
	float DecalDepthBias;
	float3 IndirectLightingColorScale;
	float3 PrecomputedIndirectLightingColorScale;
	float3 PrecomputedIndirectSpecularColorScale;
	float4 AtmosphereLightDirection[2];
	float4 AtmosphereLightIlluminanceOnGroundPostTransmittance[2];
	float4 AtmosphereLightIlluminanceOuterSpace[2];
	float4 AtmosphereLightDiscLuminance[2];
	float4 AtmosphereLightDiscCosHalfApexAngle_PPTrans[2];
	float4 SkyViewLutSizeAndInvSize;
	float3 SkyCameraTranslatedWorldOrigin;
	float4 SkyPlanetTranslatedWorldCenterAndViewHeight;
	float4x4 SkyViewLutReferential;
	float4 SkyAtmosphereSkyLuminanceFactor;
	float SkyAtmospherePresentInScene;
	float SkyAtmosphereHeightFogContribution;
	float SkyAtmosphereBottomRadiusKm;
	float SkyAtmosphereTopRadiusKm;
	float4 SkyAtmosphereCameraAerialPerspectiveVolumeSizeAndInvSize;
	float SkyAtmosphereAerialPerspectiveStartDepthKm;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolution;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKmInv;
	float SkyAtmosphereApplyCameraAerialPerspectiveVolume;
	float3 NormalCurvatureToRoughnessScaleBias;
	float RenderingReflectionCaptureMask;
	float RealTimeReflectionCapture;
	float RealTimeReflectionCapturePreExposure;
	float4 AmbientCubemapTint;
	float AmbientCubemapIntensity;
	float SkyLightApplyPrecomputedBentNormalShadowingFlag;
	float SkyLightAffectReflectionFlag;
	float SkyLightAffectGlobalIlluminationFlag;
	float4 SkyLightColor;
	float SkyLightVolumetricScatteringIntensity;
	float4 MobileSkyIrradianceEnvironmentMap[8];
	float MobilePreviewMode;
	float HMDEyePaddingOffset;
	float ReflectionCubemapMaxMip;
	float ShowDecalsMask;
	uint DistanceFieldAOSpecularOcclusionMode;
	float IndirectCapsuleSelfShadowingIntensity;
	float3 ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight;
	int StereoPassIndex;
	float4 GlobalVolumeTranslatedCenterAndExtent[6];
	float4 GlobalVolumeTranslatedWorldToUVAddAndMul[6];
	float4 GlobalDistanceFieldMipTranslatedWorldToUVScale[6];
	float4 GlobalDistanceFieldMipTranslatedWorldToUVBias[6];
	float GlobalDistanceFieldMipFactor;
	float GlobalDistanceFieldMipTransition;
	int GlobalDistanceFieldClipmapSizeInPages;
	float3 GlobalDistanceFieldInvPageAtlasSize;
	float3 GlobalDistanceFieldInvCoverageAtlasSize;
	float GlobalVolumeDimension;
	float GlobalVolumeTexelSize;
	float MaxGlobalDFAOConeDistance;
	uint NumGlobalSDFClipmaps;
	float CoveredExpandSurfaceScale;
	float NotCoveredExpandSurfaceScale;
	float NotCoveredMinStepScale;
	float DitheredTransparencyStepThreshold;
	float DitheredTransparencyTraceThreshold;
	int2 CursorPosition;
	float bCheckerboardSubsurfaceProfileRendering;
	float3 VolumetricFogInvGridSize;
	float3 VolumetricFogGridZParams;
	float2 VolumetricFogSVPosToVolumeUV;
	float2 VolumetricFogViewGridUVToPrevViewRectUV;
	float2 VolumetricFogPrevViewGridRectUVToResourceUV;
	float2 VolumetricFogPrevUVMax;
	float2 VolumetricFogPrevUVMaxForTemporalBlend;
	float2 VolumetricFogScreenToResourceUV;
	float2 VolumetricFogUVMax;
	float VolumetricFogMaxDistance;
	float3 VolumetricLightmapWorldToUVScale;
	float3 VolumetricLightmapWorldToUVAdd;
	float3 VolumetricLightmapIndirectionTextureSize;
	float VolumetricLightmapBrickSize;
	float3 VolumetricLightmapBrickTexelSize;
	float IndirectLightingCacheShowFlag;
	float EyeToPixelSpreadAngle;
	float4 XRPassthroughCameraUVs[2];
	float GlobalVirtualTextureMipBias;
	uint VirtualTextureFeedbackShift;
	uint VirtualTextureFeedbackMask;
	uint VirtualTextureFeedbackStride;
	uint VirtualTextureFeedbackJitterOffset;
	uint VirtualTextureFeedbackSampleOffset;
	float4 RuntimeVirtualTextureMipLevel;
	float2 RuntimeVirtualTexturePackHeight;
	float4 RuntimeVirtualTextureDebugParams;
	int FarShadowStaticMeshLODBias;
	float MinRoughness;
	float4 HairRenderInfo;
	uint EnableSkyLight;
	uint HairRenderInfoBits;
	uint HairComponents;
	float bSubsurfacePostprocessEnabled;
	float4 SSProfilesTextureSizeAndInvSize;
	float4 SSProfilesPreIntegratedTextureSizeAndInvSize;
	float4 SpecularProfileTextureSizeAndInvSize;
	float3 PhysicsFieldClipmapCenter;
	float PhysicsFieldClipmapDistance;
	int PhysicsFieldClipmapResolution;
	int PhysicsFieldClipmapExponent;
	int PhysicsFieldClipmapCount;
	int PhysicsFieldTargetCount;
	int4 PhysicsFieldTargets[32];
	uint GPUSceneViewId;
	float ViewResolutionFraction;
	float SubSurfaceColorAsTransmittanceAtDistanceInMeters;
	float4 TanAndInvTanHalfFOV;
	float4 PrevTanAndInvTanHalfFOV;
	float2 WorldDepthToPixelWorldRadius;
	float4 ScreenRayLengthMultiplier;
	float4 GlintLUTParameters0;
	float4 GlintLUTParameters1;
	int4 EnvironmentComponentsFlags;
	FDFInverseMatrix WorldToClip;
	FDFMatrix ClipToWorld;
	FDFMatrix ScreenToWorld;
	FDFMatrix PrevClipToWorld;
	FDFVector3 WorldCameraOrigin;
	FDFVector3 WorldViewOrigin;
	FDFVector3 PrevWorldCameraOrigin;
	FDFVector3 PrevWorldViewOrigin;
	FDFVector3 PreViewTranslation;
	FDFVector3 PrevPreViewTranslation;
	ViewStateTileOffsetData TileOffset;
};
void FinalizeViewState(inout ViewState InOutView);
ViewState GetPrimaryView()
{
	ViewState Result;
	Result.TranslatedWorldToClip = View.TranslatedWorldToClip;
	Result.RelativeWorldToClip = View.RelativeWorldToClip;
	Result.ClipToRelativeWorld = View.ClipToRelativeWorld;
	Result.TranslatedWorldToView = View.TranslatedWorldToView;
	Result.ViewToTranslatedWorld = View.ViewToTranslatedWorld;
	Result.TranslatedWorldToCameraView = View.TranslatedWorldToCameraView;
	Result.CameraViewToTranslatedWorld = View.CameraViewToTranslatedWorld;
	Result.ViewToClip = View.ViewToClip;
	Result.ViewToClipNoAA = View.ViewToClipNoAA;
	Result.ClipToView = View.ClipToView;
	Result.ClipToTranslatedWorld = View.ClipToTranslatedWorld;
	Result.SVPositionToTranslatedWorld = View.SVPositionToTranslatedWorld;
	Result.ScreenToRelativeWorld = View.ScreenToRelativeWorld;
	Result.ScreenToTranslatedWorld = View.ScreenToTranslatedWorld;
	Result.MobileMultiviewShadowTransform = View.MobileMultiviewShadowTransform;
	Result.ViewOriginHigh = View.ViewOriginHigh;
	Result.ViewForward = View.ViewForward;
	Result.ViewUp = View.ViewUp;
	Result.ViewRight = View.ViewRight;
	Result.HMDViewNoRollUp = View.HMDViewNoRollUp;
	Result.HMDViewNoRollRight = View.HMDViewNoRollRight;
	Result.InvDeviceZToWorldZTransform = View.InvDeviceZToWorldZTransform;
	Result.ScreenPositionScaleBias = View.ScreenPositionScaleBias;
	Result.ViewOriginLow = View.ViewOriginLow;
	Result.TranslatedWorldCameraOrigin = View.TranslatedWorldCameraOrigin;
	Result.WorldViewOriginHigh = View.WorldViewOriginHigh;
	Result.WorldViewOriginLow = View.WorldViewOriginLow;
	Result.PreViewTranslationHigh = View.PreViewTranslationHigh;
	Result.PreViewTranslationLow = View.PreViewTranslationLow;
	Result.PrevViewToClip = View.PrevViewToClip;
	Result.PrevClipToView = View.PrevClipToView;
	Result.PrevTranslatedWorldToClip = View.PrevTranslatedWorldToClip;
	Result.PrevTranslatedWorldToView = View.PrevTranslatedWorldToView;
	Result.PrevViewToTranslatedWorld = View.PrevViewToTranslatedWorld;
	Result.PrevTranslatedWorldToCameraView = View.PrevTranslatedWorldToCameraView;
	Result.PrevCameraViewToTranslatedWorld = View.PrevCameraViewToTranslatedWorld;
	Result.PrevTranslatedWorldCameraOrigin = View.PrevTranslatedWorldCameraOrigin;
	Result.PrevWorldCameraOriginHigh = View.PrevWorldCameraOriginHigh;
	Result.PrevWorldCameraOriginLow = View.PrevWorldCameraOriginLow;
	Result.PrevWorldViewOriginHigh = View.PrevWorldViewOriginHigh;
	Result.PrevWorldViewOriginLow = View.PrevWorldViewOriginLow;
	Result.PrevPreViewTranslationHigh = View.PrevPreViewTranslationHigh;
	Result.PrevPreViewTranslationLow = View.PrevPreViewTranslationLow;
	Result.ViewTilePosition = View.ViewTilePosition;
	Result.RelativeWorldCameraOriginTO = View.RelativeWorldCameraOriginTO;
	Result.RelativeWorldViewOriginTO = View.RelativeWorldViewOriginTO;
	Result.RelativePreViewTranslationTO = View.RelativePreViewTranslationTO;
	Result.PrevRelativeWorldCameraOriginTO = View.PrevRelativeWorldCameraOriginTO;
	Result.PrevRelativeWorldViewOriginTO = View.PrevRelativeWorldViewOriginTO;
	Result.RelativePrevPreViewTranslationTO = View.RelativePrevPreViewTranslationTO;
	Result.PrevClipToRelativeWorld = View.PrevClipToRelativeWorld;
	Result.PrevScreenToTranslatedWorld = View.PrevScreenToTranslatedWorld;
	Result.ClipToPrevClip = View.ClipToPrevClip;
	Result.ClipToPrevClipWithAA = View.ClipToPrevClipWithAA;
	Result.TemporalAAJitter = View.TemporalAAJitter;
	Result.GlobalClippingPlane = View.GlobalClippingPlane;
	Result.FieldOfViewWideAngles = View.FieldOfViewWideAngles;
	Result.PrevFieldOfViewWideAngles = View.PrevFieldOfViewWideAngles;
	Result.ViewRectMin = View.ViewRectMin;
	Result.ViewSizeAndInvSize = View.ViewSizeAndInvSize;
	Result.ViewRectMinAndSize = View.ViewRectMinAndSize;
	Result.LightProbeSizeRatioAndInvSizeRatio = View.LightProbeSizeRatioAndInvSizeRatio;
	Result.BufferSizeAndInvSize = View.BufferSizeAndInvSize;
	Result.BufferBilinearUVMinMax = View.BufferBilinearUVMinMax;
	Result.ScreenToViewSpace = View.ScreenToViewSpace;
	Result.BufferToSceneTextureScale = View.BufferToSceneTextureScale;
	Result.ResolutionFractionAndInv = View.ResolutionFractionAndInv;
	Result.NumSceneColorMSAASamples = View.NumSceneColorMSAASamples;
	Result.ProjectionDepthThicknessScale = View.ProjectionDepthThicknessScale;
	Result.PreExposure = View.PreExposure;
	Result.OneOverPreExposure = View.OneOverPreExposure;
	Result.DiffuseOverrideParameter = View.DiffuseOverrideParameter;
	Result.SpecularOverrideParameter = View.SpecularOverrideParameter;
	Result.NormalOverrideParameter = View.NormalOverrideParameter;
	Result.RoughnessOverrideParameter = View.RoughnessOverrideParameter;
	Result.PrevFrameGameTime = View.PrevFrameGameTime;
	Result.PrevFrameRealTime = View.PrevFrameRealTime;
	Result.OutOfBoundsMask = View.OutOfBoundsMask;
	Result.WorldCameraMovementSinceLastFrame = View.WorldCameraMovementSinceLastFrame;
	Result.CullingSign = View.CullingSign;
	Result.NearPlane = View.NearPlane;
	Result.GameTime = View.GameTime;
	Result.RealTime = View.RealTime;
	Result.DeltaTime = View.DeltaTime;
	Result.MaterialTextureMipBias = View.MaterialTextureMipBias;
	Result.MaterialTextureDerivativeMultiply = View.MaterialTextureDerivativeMultiply;
	Result.Random = View.Random;
	Result.FrameNumber = View.FrameNumber;
	Result.FrameCounter = View.FrameCounter;
	Result.StateFrameIndexMod8 = View.StateFrameIndexMod8;
	Result.StateFrameIndex = View.StateFrameIndex;
	Result.DebugViewModeMask = View.DebugViewModeMask;
	Result.WorldIsPaused = View.WorldIsPaused;
	Result.CameraCut = View.CameraCut;
	Result.UnlitViewmodeMask = View.UnlitViewmodeMask;
	Result.DirectionalLightColor = View.DirectionalLightColor;
	Result.DirectionalLightDirection = View.DirectionalLightDirection;
	Result.TranslucencyLightingVolumeMin = View.TranslucencyLightingVolumeMin;
	Result.TranslucencyLightingVolumeInvSize = View.TranslucencyLightingVolumeInvSize;
	Result.TemporalAAParams = View.TemporalAAParams;
	Result.CircleDOFParams = View.CircleDOFParams;
	Result.DepthOfFieldSensorWidth = View.DepthOfFieldSensorWidth;
	Result.DepthOfFieldFocalDistance = View.DepthOfFieldFocalDistance;
	Result.DepthOfFieldScale = View.DepthOfFieldScale;
	Result.DepthOfFieldFocalLength = View.DepthOfFieldFocalLength;
	Result.DepthOfFieldFocalRegion = View.DepthOfFieldFocalRegion;
	Result.DepthOfFieldNearTransitionRegion = View.DepthOfFieldNearTransitionRegion;
	Result.DepthOfFieldFarTransitionRegion = View.DepthOfFieldFarTransitionRegion;
	Result.MotionBlurNormalizedToPixel = View.MotionBlurNormalizedToPixel;
	Result.GeneralPurposeTweak = View.GeneralPurposeTweak;
	Result.GeneralPurposeTweak2 = View.GeneralPurposeTweak2;
	Result.DemosaicVposOffset = View.DemosaicVposOffset;
	Result.DecalDepthBias = View.DecalDepthBias;
	Result.IndirectLightingColorScale = View.IndirectLightingColorScale;
	Result.PrecomputedIndirectLightingColorScale = View.PrecomputedIndirectLightingColorScale;
	Result.PrecomputedIndirectSpecularColorScale = View.PrecomputedIndirectSpecularColorScale;
	Result.AtmosphereLightDirection = View.AtmosphereLightDirection;
	Result.AtmosphereLightIlluminanceOnGroundPostTransmittance = View.AtmosphereLightIlluminanceOnGroundPostTransmittance;
	Result.AtmosphereLightIlluminanceOuterSpace = View.AtmosphereLightIlluminanceOuterSpace;
	Result.AtmosphereLightDiscLuminance = View.AtmosphereLightDiscLuminance;
	Result.AtmosphereLightDiscCosHalfApexAngle_PPTrans = View.AtmosphereLightDiscCosHalfApexAngle_PPTrans;
	Result.SkyViewLutSizeAndInvSize = View.SkyViewLutSizeAndInvSize;
	Result.SkyCameraTranslatedWorldOrigin = View.SkyCameraTranslatedWorldOrigin;
	Result.SkyPlanetTranslatedWorldCenterAndViewHeight = View.SkyPlanetTranslatedWorldCenterAndViewHeight;
	Result.SkyViewLutReferential = View.SkyViewLutReferential;
	Result.SkyAtmosphereSkyLuminanceFactor = View.SkyAtmosphereSkyLuminanceFactor;
	Result.SkyAtmospherePresentInScene = View.SkyAtmospherePresentInScene;
	Result.SkyAtmosphereHeightFogContribution = View.SkyAtmosphereHeightFogContribution;
	Result.SkyAtmosphereBottomRadiusKm = View.SkyAtmosphereBottomRadiusKm;
	Result.SkyAtmosphereTopRadiusKm = View.SkyAtmosphereTopRadiusKm;
	Result.SkyAtmosphereCameraAerialPerspectiveVolumeSizeAndInvSize = View.SkyAtmosphereCameraAerialPerspectiveVolumeSizeAndInvSize;
	Result.SkyAtmosphereAerialPerspectiveStartDepthKm = View.SkyAtmosphereAerialPerspectiveStartDepthKm;
	Result.SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolution = View.SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolution;
	Result.SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv = View.SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv;
	Result.SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm = View.SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm;
	Result.SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKmInv = View.SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKmInv;
	Result.SkyAtmosphereApplyCameraAerialPerspectiveVolume = View.SkyAtmosphereApplyCameraAerialPerspectiveVolume;
	Result.NormalCurvatureToRoughnessScaleBias = View.NormalCurvatureToRoughnessScaleBias;
	Result.RenderingReflectionCaptureMask = View.RenderingReflectionCaptureMask;
	Result.RealTimeReflectionCapture = View.RealTimeReflectionCapture;
	Result.RealTimeReflectionCapturePreExposure = View.RealTimeReflectionCapturePreExposure;
	Result.AmbientCubemapTint = View.AmbientCubemapTint;
	Result.AmbientCubemapIntensity = View.AmbientCubemapIntensity;
	Result.SkyLightApplyPrecomputedBentNormalShadowingFlag = View.SkyLightApplyPrecomputedBentNormalShadowingFlag;
	Result.SkyLightAffectReflectionFlag = View.SkyLightAffectReflectionFlag;
	Result.SkyLightAffectGlobalIlluminationFlag = View.SkyLightAffectGlobalIlluminationFlag;
	Result.SkyLightColor = View.SkyLightColor;
	Result.SkyLightVolumetricScatteringIntensity = View.SkyLightVolumetricScatteringIntensity;
	Result.MobileSkyIrradianceEnvironmentMap = View.MobileSkyIrradianceEnvironmentMap;
	Result.MobilePreviewMode = View.MobilePreviewMode;
	Result.HMDEyePaddingOffset = View.HMDEyePaddingOffset;
	Result.ReflectionCubemapMaxMip = View.ReflectionCubemapMaxMip;
	Result.ShowDecalsMask = View.ShowDecalsMask;
	Result.DistanceFieldAOSpecularOcclusionMode = View.DistanceFieldAOSpecularOcclusionMode;
	Result.IndirectCapsuleSelfShadowingIntensity = View.IndirectCapsuleSelfShadowingIntensity;
	Result.ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight = View.ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight;
	Result.StereoPassIndex = View.StereoPassIndex;
	Result.GlobalVolumeTranslatedCenterAndExtent = View.GlobalVolumeTranslatedCenterAndExtent;
	Result.GlobalVolumeTranslatedWorldToUVAddAndMul = View.GlobalVolumeTranslatedWorldToUVAddAndMul;
	Result.GlobalDistanceFieldMipTranslatedWorldToUVScale = View.GlobalDistanceFieldMipTranslatedWorldToUVScale;
	Result.GlobalDistanceFieldMipTranslatedWorldToUVBias = View.GlobalDistanceFieldMipTranslatedWorldToUVBias;
	Result.GlobalDistanceFieldMipFactor = View.GlobalDistanceFieldMipFactor;
	Result.GlobalDistanceFieldMipTransition = View.GlobalDistanceFieldMipTransition;
	Result.GlobalDistanceFieldClipmapSizeInPages = View.GlobalDistanceFieldClipmapSizeInPages;
	Result.GlobalDistanceFieldInvPageAtlasSize = View.GlobalDistanceFieldInvPageAtlasSize;
	Result.GlobalDistanceFieldInvCoverageAtlasSize = View.GlobalDistanceFieldInvCoverageAtlasSize;
	Result.GlobalVolumeDimension = View.GlobalVolumeDimension;
	Result.GlobalVolumeTexelSize = View.GlobalVolumeTexelSize;
	Result.MaxGlobalDFAOConeDistance = View.MaxGlobalDFAOConeDistance;
	Result.NumGlobalSDFClipmaps = View.NumGlobalSDFClipmaps;
	Result.CoveredExpandSurfaceScale = View.CoveredExpandSurfaceScale;
	Result.NotCoveredExpandSurfaceScale = View.NotCoveredExpandSurfaceScale;
	Result.NotCoveredMinStepScale = View.NotCoveredMinStepScale;
	Result.DitheredTransparencyStepThreshold = View.DitheredTransparencyStepThreshold;
	Result.DitheredTransparencyTraceThreshold = View.DitheredTransparencyTraceThreshold;
	Result.CursorPosition = View.CursorPosition;
	Result.bCheckerboardSubsurfaceProfileRendering = View.bCheckerboardSubsurfaceProfileRendering;
	Result.VolumetricFogInvGridSize = View.VolumetricFogInvGridSize;
	Result.VolumetricFogGridZParams = View.VolumetricFogGridZParams;
	Result.VolumetricFogSVPosToVolumeUV = View.VolumetricFogSVPosToVolumeUV;
	Result.VolumetricFogViewGridUVToPrevViewRectUV = View.VolumetricFogViewGridUVToPrevViewRectUV;
	Result.VolumetricFogPrevViewGridRectUVToResourceUV = View.VolumetricFogPrevViewGridRectUVToResourceUV;
	Result.VolumetricFogPrevUVMax = View.VolumetricFogPrevUVMax;
	Result.VolumetricFogPrevUVMaxForTemporalBlend = View.VolumetricFogPrevUVMaxForTemporalBlend;
	Result.VolumetricFogScreenToResourceUV = View.VolumetricFogScreenToResourceUV;
	Result.VolumetricFogUVMax = View.VolumetricFogUVMax;
	Result.VolumetricFogMaxDistance = View.VolumetricFogMaxDistance;
	Result.VolumetricLightmapWorldToUVScale = View.VolumetricLightmapWorldToUVScale;
	Result.VolumetricLightmapWorldToUVAdd = View.VolumetricLightmapWorldToUVAdd;
	Result.VolumetricLightmapIndirectionTextureSize = View.VolumetricLightmapIndirectionTextureSize;
	Result.VolumetricLightmapBrickSize = View.VolumetricLightmapBrickSize;
	Result.VolumetricLightmapBrickTexelSize = View.VolumetricLightmapBrickTexelSize;
	Result.IndirectLightingCacheShowFlag = View.IndirectLightingCacheShowFlag;
	Result.EyeToPixelSpreadAngle = View.EyeToPixelSpreadAngle;
	Result.XRPassthroughCameraUVs = View.XRPassthroughCameraUVs;
	Result.GlobalVirtualTextureMipBias = View.GlobalVirtualTextureMipBias;
	Result.VirtualTextureFeedbackShift = View.VirtualTextureFeedbackShift;
	Result.VirtualTextureFeedbackMask = View.VirtualTextureFeedbackMask;
	Result.VirtualTextureFeedbackStride = View.VirtualTextureFeedbackStride;
	Result.VirtualTextureFeedbackJitterOffset = View.VirtualTextureFeedbackJitterOffset;
	Result.VirtualTextureFeedbackSampleOffset = View.VirtualTextureFeedbackSampleOffset;
	Result.RuntimeVirtualTextureMipLevel = View.RuntimeVirtualTextureMipLevel;
	Result.RuntimeVirtualTexturePackHeight = View.RuntimeVirtualTexturePackHeight;
	Result.RuntimeVirtualTextureDebugParams = View.RuntimeVirtualTextureDebugParams;
	Result.FarShadowStaticMeshLODBias = View.FarShadowStaticMeshLODBias;
	Result.MinRoughness = View.MinRoughness;
	Result.HairRenderInfo = View.HairRenderInfo;
	Result.EnableSkyLight = View.EnableSkyLight;
	Result.HairRenderInfoBits = View.HairRenderInfoBits;
	Result.HairComponents = View.HairComponents;
	Result.bSubsurfacePostprocessEnabled = View.bSubsurfacePostprocessEnabled;
	Result.SSProfilesTextureSizeAndInvSize = View.SSProfilesTextureSizeAndInvSize;
	Result.SSProfilesPreIntegratedTextureSizeAndInvSize = View.SSProfilesPreIntegratedTextureSizeAndInvSize;
	Result.SpecularProfileTextureSizeAndInvSize = View.SpecularProfileTextureSizeAndInvSize;
	Result.PhysicsFieldClipmapCenter = View.PhysicsFieldClipmapCenter;
	Result.PhysicsFieldClipmapDistance = View.PhysicsFieldClipmapDistance;
	Result.PhysicsFieldClipmapResolution = View.PhysicsFieldClipmapResolution;
	Result.PhysicsFieldClipmapExponent = View.PhysicsFieldClipmapExponent;
	Result.PhysicsFieldClipmapCount = View.PhysicsFieldClipmapCount;
	Result.PhysicsFieldTargetCount = View.PhysicsFieldTargetCount;
	Result.PhysicsFieldTargets = View.PhysicsFieldTargets;
	Result.GPUSceneViewId = View.GPUSceneViewId;
	Result.ViewResolutionFraction = View.ViewResolutionFraction;
	Result.SubSurfaceColorAsTransmittanceAtDistanceInMeters = View.SubSurfaceColorAsTransmittanceAtDistanceInMeters;
	Result.TanAndInvTanHalfFOV = View.TanAndInvTanHalfFOV;
	Result.PrevTanAndInvTanHalfFOV = View.PrevTanAndInvTanHalfFOV;
	Result.WorldDepthToPixelWorldRadius = View.WorldDepthToPixelWorldRadius;
	Result.ScreenRayLengthMultiplier = View.ScreenRayLengthMultiplier;
	Result.GlintLUTParameters0 = View.GlintLUTParameters0;
	Result.GlintLUTParameters1 = View.GlintLUTParameters1;
	Result.EnvironmentComponentsFlags = View.EnvironmentComponentsFlags;
	FinalizeViewState(Result);
	return Result;
}
void FinalizeViewState(inout ViewState InOutView)
{
	InOutView.WorldToClip = MakeDFInverseMatrix(InOutView.ViewOriginHigh, InOutView.RelativeWorldToClip);
	InOutView.ClipToWorld = MakeDFMatrix(InOutView.ViewOriginHigh, InOutView.ClipToRelativeWorld);
	InOutView.ScreenToWorld = MakeDFMatrix(InOutView.ViewOriginHigh, InOutView.ScreenToRelativeWorld);
	InOutView.PrevClipToWorld = MakeDFMatrix(InOutView.ViewOriginHigh, InOutView.PrevClipToRelativeWorld);
	InOutView.WorldCameraOrigin = MakeDFVector3(InOutView.ViewOriginHigh, InOutView.ViewOriginLow);
	InOutView.WorldViewOrigin = MakeDFVector3(InOutView.WorldViewOriginHigh, InOutView.WorldViewOriginLow);
	InOutView.PrevWorldCameraOrigin = MakeDFVector3(InOutView.PrevWorldCameraOriginHigh, InOutView.PrevWorldCameraOriginLow);
	InOutView.PrevWorldViewOrigin = MakeDFVector3(InOutView.PrevWorldViewOriginHigh, InOutView.PrevWorldViewOriginLow);
	InOutView.PreViewTranslation = MakeDFVector3(InOutView.PreViewTranslationHigh, InOutView.PreViewTranslationLow);
	InOutView.PrevPreViewTranslation = MakeDFVector3(InOutView.PrevPreViewTranslationHigh, InOutView.PrevPreViewTranslationLow);
	InOutView.TileOffset.WorldCameraOrigin = MakeLWCVector3(InOutView.ViewTilePosition, InOutView.RelativeWorldCameraOriginTO);
	InOutView.TileOffset.WorldViewOrigin = MakeLWCVector3(InOutView.ViewTilePosition, InOutView.RelativeWorldViewOriginTO);
	InOutView.TileOffset.PrevWorldCameraOrigin = MakeLWCVector3(InOutView.ViewTilePosition, InOutView.PrevRelativeWorldCameraOriginTO);
	InOutView.TileOffset.PrevWorldViewOrigin = MakeLWCVector3(InOutView.ViewTilePosition, InOutView.PrevRelativeWorldViewOriginTO);
	InOutView.TileOffset.PreViewTranslation = MakeLWCVector3(-InOutView.ViewTilePosition, InOutView.RelativePreViewTranslationTO);
	InOutView.TileOffset.PrevPreViewTranslation = MakeLWCVector3(-InOutView.ViewTilePosition, InOutView.RelativePrevPreViewTranslationTO);
}
static ViewState ResolvedView = (ViewState)0.0f;
float length2(float2 v)
{
	return dot(v, v);
}
float length2(float3 v)
{
	return dot(v, v);
}
float length2(float4 v)
{
	return dot(v, v);
}
float InterleavedGradientNoise( float2 uv, float FrameId )
{
	uv += FrameId * (float2(47, 17) * 0.695f);
    const float3 magic = float3( 0.06711056f, 0.00583715f, 52.9829189f );
    return frac(magic.z * frac(dot(uv, magic.xy)));
}
float Pow2( float x )
{
	return x*x;
}
float2 Pow2( float2 x )
{
	return x*x;
}
float3 Pow2( float3 x )
{
	return x*x;
}
float4 Pow2( float4 x )
{
	return x*x;
}
float ConvertFromDeviceZ(float DeviceZ)
{
	return DeviceZ * View.InvDeviceZToWorldZTransform[0] + View.InvDeviceZToWorldZTransform[1] + 1.0f / (DeviceZ * View.InvDeviceZToWorldZTransform[2] - View.InvDeviceZToWorldZTransform[3]);
}
bool IsOrthoProjection(float4x4 ViewToClip)
{
	return ViewToClip._44 >= 1.0f;
}
bool IsOrthoProjection(ViewState InView)
{
	return IsOrthoProjection(InView.ViewToClip);
}
bool IsOrthoProjection()
{
	return IsOrthoProjection(View.ViewToClip);
}
float ConvertToDeviceZ(float SceneDepth)
{
	[flatten]
	if (IsOrthoProjection())
	{
		return SceneDepth * View.ViewToClip[2][2] + View.ViewToClip[3][2];
	}
	else
	{
		return 1.0f / ((SceneDepth + View.InvDeviceZToWorldZTransform[3]) * View.InvDeviceZToWorldZTransform[2]);
	}
}
float3 GetCameraVector(float3 Position, float3 CameraPosition)
{
	return  select_internal( IsOrthoProjection() , View.ViewForward , normalize(Position - CameraPosition) );
}
float3 GetCameraVectorFromTranslatedWorldPosition(float3 TranslatedWorldPosition)
{
	return GetCameraVector(TranslatedWorldPosition, GetPrimaryView().TranslatedWorldCameraOrigin);
}
float2 GetScreenPositionForProjectionType(float2 ScreenPosition, float SceneDepth)
{
	return  select_internal( IsOrthoProjection() , ScreenPosition , ScreenPosition * SceneDepth );
}
float GetDepthPixelRadiusForProjectionType(float SceneDepth)
{
	return View.WorldDepthToPixelWorldRadius.x * SceneDepth + View.WorldDepthToPixelWorldRadius.y;
}
float3 DecodeVelocityFromTexture(float4 InEncodedV)
{
	float4 EncodedV = InEncodedV;
	const float InvDiv = 1.0f / (0.499f * 0.5f);
	float3 V;
	V.xy = EncodedV.xy * InvDiv - 32767.0f / 65535.0f * InvDiv;
		V.z = asfloat((uint(round(EncodedV.z * 65535.0f)) << 16) | (uint(round(EncodedV.w * 65535.0f)) & 0xFFFE));
		V.xy = (V.xy * abs(V.xy)) * 0.5;
	return V;
}
float DielectricSpecularToF0(float Specular)
{
	return float(0.08f * Specular);
}
float3 ComputeF0(float Specular, float3 BaseColor, float Metallic)
{
	return lerp(DielectricSpecularToF0(Specular).xxx, BaseColor, Metallic.xxx);
}
Texture2D SceneDepthTexture;
Texture2D GBufferATexture;
Texture2D GBufferBTexture;
Texture2D GBufferCTexture;
Texture2D GBufferDTexture;
Texture2D GBufferETexture;
Texture2D GBufferVelocityTexture;
Texture2D GBufferFTexture;
float3 DecodeNormal( float3 N )
{
	return N * 2 - 1;
}
void DecodeNormal( inout float3 N, in uint Face )
{
	uint Axis = Face >> 1;
	float MaxAbs = 1.0 / sqrt(2.0);
	N.xy = N.xy * (2 * MaxAbs) - (1 * MaxAbs);
	N.z = sqrt( 1 - dot( N.xy, N.xy ) );
	N = Axis == 0 ? N.zxy : N;
	N = Axis == 1 ? N.xzy : N;
	N *= (Face & 1) ? -1 : 1;
}
float3 DecodeBaseColor(float3 BaseColor)
{
	return BaseColor;
}
float DecodeIndirectIrradiance(float IndirectIrradiance)
{
	float LogL = IndirectIrradiance;
	const float LogBlackPoint = 0.00390625;	
	return View.OneOverPreExposure * (exp2( LogL * 16 - 8 ) - LogBlackPoint);	
}
uint DecodeShadingModelId(float InPackedChannel)
{
	return ((uint)round(InPackedChannel * (float)0xFF)) & 0xF;
}
uint DecodeSelectiveOutputMask(float InPackedChannel)
{
	return ((uint)round(InPackedChannel * (float)0xFF)) & ~0xF;
}
bool UseSubsurfaceProfile(int ShadingModel)
{
	return ShadingModel == 5 || ShadingModel == 9;
}
bool HasCustomGBufferData(int ShadingModelID)
{
	return ShadingModelID == 2
		|| ShadingModelID == 3
		|| ShadingModelID == 4
		|| ShadingModelID == 5
		|| ShadingModelID == 6
		|| ShadingModelID == 7
		|| ShadingModelID == 8
		|| ShadingModelID == 9;
}
bool HasAnisotropy(int SelectiveOutputMask)
{
	return (SelectiveOutputMask & (1 << 4)) != 0;
}
struct FGBufferData
{
	float3 WorldNormal;
	float3 WorldTangent;
	float3 DiffuseColor;
	float3 SpecularColor;
	float3 BaseColor;
	float Metallic;
	float Specular;
	float4 CustomData;
	float GenericAO;
	float IndirectIrradiance;
	float4 PrecomputedShadowFactors;
	float Roughness;
	float Anisotropy;
	float GBufferAO;
	uint DiffuseIndirectSampleOcclusion;
	uint ShadingModelID;
	uint SelectiveOutputMask;
	float PerObjectGBufferData;
	float CustomDepth;
	uint CustomStencil;
	float Depth;
	float4 Velocity;
	float3 StoredBaseColor;
	float StoredSpecular;
	float StoredMetallic;
	float Curvature;
};
bool CheckerFromPixelPos(uint2 PixelPos)
{
	uint TemporalAASampleIndex = uint(View.TemporalAAParams.x);
	return (PixelPos.x + PixelPos.y + TemporalAASampleIndex) % 2;
}
bool CheckerFromSceneColorUV(float2 UVSceneColor)
{
	uint2 PixelPos = uint2(UVSceneColor * View.BufferSizeAndInvSize.xy);
	return CheckerFromPixelPos(PixelPos);
}
float3 DecodeNormalHelper(float3 SrcNormal)
{
	return SrcNormal * 2.0f - 1.0f;
}
void AdjustBaseColorAndSpecularColorForSubsurfaceProfileLightingCopyHack(inout float3 BaseColor, inout float3 SpecularColor, inout float Specular, bool bChecker)
{
	const bool bCheckerboardRequired = View.bSubsurfacePostprocessEnabled > 0 && View.bCheckerboardSubsurfaceProfileRendering > 0;
	BaseColor = View.bSubsurfacePostprocessEnabled ? float3(1, 1, 1) : BaseColor;
	if (bCheckerboardRequired)
	{
		BaseColor = bChecker;
		SpecularColor *= !bChecker;
		Specular *= !bChecker;
	}
}
void GBufferPostDecode(inout FGBufferData Ret, bool bChecker, bool bGetNormalizedNormal)
{
	Ret.CustomData = HasCustomGBufferData(Ret.ShadingModelID) ? Ret.CustomData : float(0.0f);
	Ret.PrecomputedShadowFactors = !(Ret.SelectiveOutputMask & 0x2) ? Ret.PrecomputedShadowFactors : ((Ret.SelectiveOutputMask & 0x4) ? float(0.0f) : float(1.0f));
	Ret.Velocity = !(Ret.SelectiveOutputMask & 0x8) ? Ret.Velocity : float(0.0f);
	bool bHasAnisotropy = (Ret.SelectiveOutputMask & 0x1);
	Ret.StoredBaseColor = Ret.BaseColor;
	Ret.StoredMetallic = Ret.Metallic;
	Ret.StoredSpecular = Ret.Specular;
	Ret.GBufferAO = 1;
	Ret.DiffuseIndirectSampleOcclusion = 0x0;
	Ret.IndirectIrradiance = float(DecodeIndirectIrradiance(Ret.GenericAO.x));
	if(bGetNormalizedNormal)
	{
		Ret.WorldNormal = normalize(Ret.WorldNormal);
	}
	[flatten]
	if( Ret.ShadingModelID == 9 )
	{
		Ret.Metallic = 0.0;
	}
	{
		Ret.SpecularColor = ComputeF0(Ret.Specular, Ret.BaseColor, Ret.Metallic);
		if (UseSubsurfaceProfile(Ret.ShadingModelID))
		{
			AdjustBaseColorAndSpecularColorForSubsurfaceProfileLightingCopyHack(Ret.BaseColor, Ret.SpecularColor, Ret.Specular, bChecker);
		}
		Ret.DiffuseColor = Ret.BaseColor - Ret.BaseColor * Ret.Metallic;
		{
			Ret.DiffuseColor = Ret.DiffuseColor * View.DiffuseOverrideParameter.www + View.DiffuseOverrideParameter.xyz;
			Ret.SpecularColor = Ret.SpecularColor * View.SpecularOverrideParameter.w + View.SpecularOverrideParameter.xyz;
		}
	}
	if (bHasAnisotropy)
	{
		Ret.WorldTangent = float3(DecodeNormal(Ret.WorldTangent));
		Ret.Anisotropy = float(Ret.Anisotropy * 2.0f - 1.0f);
		if(bGetNormalizedNormal)
		{
			Ret.WorldTangent = normalize(Ret.WorldTangent);
		}
	}
	else
	{
		Ret.WorldTangent = 0;
		Ret.Anisotropy = 0;
	}
	Ret.SelectiveOutputMask = Ret.SelectiveOutputMask << 4;
}
float SampleDeviceZFromSceneTexturesTempCopy(float2 UV)
{
	return SceneDepthTexture.SampleLevel( D3DStaticPointClampedSampler, UV, 0).r;
}
FGBufferData  DecodeGBufferDataDirect(float4 InMRT1,
	float4 InMRT2,
	float4 InMRT3,
	float4 InMRT4,
	float4 InMRT5,
	float CustomNativeDepth,
	float4 AnisotropicData,
	uint CustomStencil,
	float SceneDepth,
	bool bGetNormalizedNormal,
	bool bChecker)
{
	FGBufferData Ret = (FGBufferData)0;
	float3 WorldNormal_Compressed = 0.0f;
	WorldNormal_Compressed.x = InMRT1.x;
	WorldNormal_Compressed.y = InMRT1.y;
	WorldNormal_Compressed.z = InMRT1.z;
	Ret.PerObjectGBufferData.x = InMRT1.w;
	Ret.Metallic.x = InMRT2.x;
	Ret.Specular.x = InMRT2.y;
	Ret.Roughness.x = InMRT2.z;
	Ret.ShadingModelID.x = (((uint((float(InMRT2.w) * 255.0f) + .5f) >> 0) & 0x0f) << 0);
	Ret.SelectiveOutputMask.x = (((uint((float(InMRT2.w) * 255.0f) + .5f) >> 4) & 0x0f) << 0);
	Ret.BaseColor.x = InMRT3.x;
	Ret.BaseColor.y = InMRT3.y;
	Ret.BaseColor.z = InMRT3.z;
	Ret.GenericAO.x = InMRT3.w;
	Ret.PrecomputedShadowFactors.x = InMRT5.x;
	Ret.PrecomputedShadowFactors.y = InMRT5.y;
	Ret.PrecomputedShadowFactors.z = InMRT5.z;
	Ret.PrecomputedShadowFactors.w = InMRT5.w;
	Ret.CustomData.x = InMRT4.x;
	Ret.CustomData.y = InMRT4.y;
	Ret.CustomData.z = InMRT4.z;
	Ret.CustomData.w = InMRT4.w;
	Ret.WorldNormal = DecodeNormalHelper(WorldNormal_Compressed);
	Ret.WorldTangent = AnisotropicData.xyz;
	Ret.Anisotropy = AnisotropicData.w;
	GBufferPostDecode(Ret,bChecker,bGetNormalizedNormal);
	Ret.CustomDepth = ConvertFromDeviceZ(CustomNativeDepth);
	Ret.CustomStencil = CustomStencil;
	Ret.Depth = SceneDepth;
	return Ret;
}
FGBufferData DecodeGBufferDataSceneTextures(float2 UV, bool bGetNormalizedNormal = true)
{
	uint CustomStencil = 0;
	float CustomNativeDepth = 0;
	float DeviceZ = SampleDeviceZFromSceneTexturesTempCopy(UV);
	float SceneDepth = ConvertFromDeviceZ(DeviceZ);
	float4 AnisotropicData = GBufferFTexture.SampleLevel( D3DStaticPointClampedSampler, UV, 0).xyzw;
	float4 InMRT1 = GBufferATexture.SampleLevel( D3DStaticPointClampedSampler, UV, 0).xyzw;
	float4 InMRT2 = GBufferBTexture.SampleLevel( D3DStaticPointClampedSampler, UV, 0).xyzw;
	float4 InMRT3 = GBufferCTexture.SampleLevel( D3DStaticPointClampedSampler, UV, 0).xyzw;
	float4 InMRT4 = GBufferDTexture.SampleLevel( D3DStaticPointClampedSampler, UV, 0).xyzw;
	float4 InMRT5 = GBufferETexture.SampleLevel( D3DStaticPointClampedSampler, UV, 0).xyzw;
	FGBufferData Ret = DecodeGBufferDataDirect(InMRT1,
		InMRT2,
		InMRT3,
		InMRT4,
		InMRT5,
		CustomNativeDepth,
		AnisotropicData,
		CustomStencil,
		SceneDepth,
		bGetNormalizedNormal,
		CheckerFromSceneColorUV(UV));
	return Ret;
}
bool AdjustBaseColorAndSpecularColorForSubsurfaceProfileLighting(inout float3 BaseColor, inout float Specular, bool bChecker)
{
	const bool bCheckerboardRequired = View.bSubsurfacePostprocessEnabled > 0 && View.bCheckerboardSubsurfaceProfileRendering > 0;
	BaseColor = View.bSubsurfacePostprocessEnabled ? float3(1, 1, 1) : BaseColor;
	if (bCheckerboardRequired)
	{
		BaseColor = bChecker;
		Specular *= !bChecker;
	}
	return bCheckerboardRequired;
}
void AdjustBaseColorAndSpecularColorForSubsurfaceProfileLighting(inout float3 BaseColor, inout float3 SpecularColor, inout float Specular, bool bChecker)
{
	const bool bCheckerboardRequired = AdjustBaseColorAndSpecularColorForSubsurfaceProfileLighting(BaseColor, Specular, bChecker);
	if (bCheckerboardRequired)
	{
		SpecularColor *= !bChecker;
	}
}
FGBufferData DecodeGBufferData(
	float4 InGBufferA,
	float4 InGBufferB,
	float4 InGBufferC,
	float4 InGBufferD,
	float4 InGBufferE,
	float4 InGBufferF,
	float4 InGBufferVelocity,
	float CustomNativeDepth,
	uint CustomStencil,
	float SceneDepth,
	bool bGetNormalizedNormal,
	bool bChecker)
{
	FGBufferData GBuffer;
	GBuffer.WorldNormal = DecodeNormal( InGBufferA.xyz );
	if(bGetNormalizedNormal)
	{
		GBuffer.WorldNormal = normalize(GBuffer.WorldNormal);
	}
	GBuffer.PerObjectGBufferData = InGBufferA.a;  
	GBuffer.Metallic	= InGBufferB.r;
	GBuffer.Specular	= InGBufferB.g;
	GBuffer.Roughness	= InGBufferB.b;
	GBuffer.ShadingModelID = DecodeShadingModelId(InGBufferB.a);
	GBuffer.SelectiveOutputMask = DecodeSelectiveOutputMask(InGBufferB.a);
	GBuffer.BaseColor = DecodeBaseColor(InGBufferC.rgb);
	GBuffer.GBufferAO = 1;
	GBuffer.DiffuseIndirectSampleOcclusion = 0x0;
	GBuffer.IndirectIrradiance = DecodeIndirectIrradiance(InGBufferC.a);
	GBuffer.CustomData = HasCustomGBufferData(GBuffer.ShadingModelID) ? InGBufferD : 0;
	GBuffer.PrecomputedShadowFactors = !(GBuffer.SelectiveOutputMask & (1 << 5)) ? InGBufferE :  ((GBuffer.SelectiveOutputMask & (1 << 6)) ? 0 :  1);
	GBuffer.CustomDepth = ConvertFromDeviceZ(CustomNativeDepth);
	GBuffer.CustomStencil = CustomStencil;
	GBuffer.Depth = SceneDepth;
	GBuffer.StoredBaseColor = GBuffer.BaseColor;
	GBuffer.StoredMetallic = GBuffer.Metallic;
	GBuffer.StoredSpecular = GBuffer.Specular;
	[flatten]
	if( GBuffer.ShadingModelID == 9 )
	{
		GBuffer.Metallic = 0.0;
	}
	{
		GBuffer.SpecularColor = ComputeF0(GBuffer.Specular, GBuffer.BaseColor, GBuffer.Metallic);
		if (UseSubsurfaceProfile(GBuffer.ShadingModelID))
		{
			AdjustBaseColorAndSpecularColorForSubsurfaceProfileLighting(GBuffer.BaseColor, GBuffer.SpecularColor, GBuffer.Specular, bChecker);
		}
		GBuffer.DiffuseColor = GBuffer.BaseColor - GBuffer.BaseColor * GBuffer.Metallic;
		{
			GBuffer.DiffuseColor = GBuffer.DiffuseColor * View.DiffuseOverrideParameter.www + View.DiffuseOverrideParameter.xyz;
			GBuffer.SpecularColor = GBuffer.SpecularColor * View.SpecularOverrideParameter.w + View.SpecularOverrideParameter.xyz;
		}
	}
	{
		bool bHasAnisoProp = HasAnisotropy(GBuffer.SelectiveOutputMask);
		GBuffer.WorldTangent = bHasAnisoProp ? DecodeNormal(InGBufferF.rgb) : 0;
		GBuffer.Anisotropy   = bHasAnisoProp ? InGBufferF.a * 2.0f - 1.0f   : 0;
		if (bGetNormalizedNormal && bHasAnisoProp)
		{
			GBuffer.WorldTangent = normalize(GBuffer.WorldTangent);
		}
	}
	GBuffer.Velocity = !(GBuffer.SelectiveOutputMask & (1 << 7)) ? InGBufferVelocity : 0;
	return GBuffer;
}
FGBufferData GetGBufferDataFromSceneTextures(float2 UV, bool bGetNormalizedNormal = true)
{
	return DecodeGBufferDataSceneTextures(UV,bGetNormalizedNormal);
}
float3 LinearRGB_2_YCoCg(float3 RGB)
{
	float Y = dot(RGB, float3(1, 2, 1));
	float Co = dot(RGB, float3(2, 0, -2));
	float Cg = dot(RGB, float3(-1, 2, -1));
	float3 YCoCg = float3(Y, Co, Cg);
	return YCoCg;
}
float3 YCoCg_2_LinearRGB(float3 YCoCg)
{
	float Y = YCoCg.x * 0.25;
	float Co = YCoCg.y * 0.25;
	float Cg = YCoCg.z * 0.25;
	float R = Y + Co - Cg;
	float G = Y + Cg;
	float B = Y - Co - Cg;
	float3 RGB = float3(R, G, B);
	return RGB;
}
float3 YCoCg_2_LCoCg(float3 YCoCg)
{
	return float3(
		YCoCg.x,
		YCoCg.yz * (YCoCg.x > 0 ? rcp(YCoCg.x) : 0));
}
float3 LCoCg_2_YCoCg(float3 LCoCg)
{
	return float3(LCoCg.x, LCoCg.x * LCoCg.yz);
}
float3 LinearRGB_2_LCoCg(float3 RGB)
{
	return YCoCg_2_LCoCg(LinearRGB_2_YCoCg(RGB));
}
float3 LCoCg_2_LinearRGB(float3 LCoCg)
{
	return YCoCg_2_LinearRGB(LCoCg_2_YCoCg(LCoCg));
}
struct FSphericalGaussian
{
	float3	Axis;		
	float	Sharpness;	
	float	Amplitude;	
};
struct FWaveBroadcastSettings
{
	uint Operation;
	uint SourceLaneIndex;
	uint GroupThreadIndex;
	uint SwizzleAnd;
	uint SwizzleOr;
	uint SwizzleXor;
	int Rotate;
	uint RotateFixMask;
};
uint GetWaveBroadcastSourceLaneIndex(const FWaveBroadcastSettings Settings, uint DestLaneIndex)
{
	if (0)
	{
		 return DestLaneIndex;
	}
	else if (Settings.Operation == 1)
	{
		return Settings.SourceLaneIndex;
	}
	else if (Settings.Operation == 2)
	{
		return Settings.SourceLaneIndex;
	}
	else if (Settings.Operation == 3)
	{
		return (((DestLaneIndex & Settings.SwizzleAnd) | Settings.SwizzleOr) ^ Settings.SwizzleXor) % 32;
	}
	else if (Settings.Operation == 4)
	{
		return (Settings.RotateFixMask & DestLaneIndex) | ((~Settings.RotateFixMask) & uint(DestLaneIndex + Settings.Rotate));
	}
	return DestLaneIndex;
}
uint WaveBroadcast(const FWaveBroadcastSettings Settings, uint x)
{
	if (0)
	{
		 return x;
	}
	else if (Settings.Operation == 1)
	{
		{
			return WaveReadLaneAt(x, Settings.SourceLaneIndex);
		}
	}
	else if (Settings.Operation == 3)
	{
		{
			return WaveReadLaneAt(x, GetWaveBroadcastSourceLaneIndex(Settings, WaveGetLaneIndex()));
		}
	}
	else if (Settings.Operation == 4)
	{
		{
			return WaveReadLaneAt(x, GetWaveBroadcastSourceLaneIndex(Settings, WaveGetLaneIndex()));
		}
	}
	return x;
}
uint2 WaveBroadcast(const FWaveBroadcastSettings Settings, uint2 v)
{
	return uint2(
		WaveBroadcast(Settings, v.x),
		WaveBroadcast(Settings, v.y));
}
uint3 WaveBroadcast(const FWaveBroadcastSettings Settings, uint3 v)
{
	return uint3(
		WaveBroadcast(Settings, v.x),
		WaveBroadcast(Settings, v.y),
		WaveBroadcast(Settings, v.z));
}
uint4 WaveBroadcast(const FWaveBroadcastSettings Settings, uint4 v)
{
	return uint4(
		WaveBroadcast(Settings, v.x),
		WaveBroadcast(Settings, v.y),
		WaveBroadcast(Settings, v.z),
		WaveBroadcast(Settings, v.w));
}
int WaveBroadcast(const FWaveBroadcastSettings Settings, int x)
{
	return asint(WaveBroadcast(Settings, asuint(x)));
}
int2 WaveBroadcast(const FWaveBroadcastSettings Settings, int2 v)
{
	return int2(
		WaveBroadcast(Settings, v.x),
		WaveBroadcast(Settings, v.y));
}
int3 WaveBroadcast(const FWaveBroadcastSettings Settings, int3 v)
{
	return int3(
		WaveBroadcast(Settings, v.x),
		WaveBroadcast(Settings, v.y),
		WaveBroadcast(Settings, v.z));
}
int4 WaveBroadcast(const FWaveBroadcastSettings Settings, int4 v)
{
	return int4(
		WaveBroadcast(Settings, v.x),
		WaveBroadcast(Settings, v.y),
		WaveBroadcast(Settings, v.z),
		WaveBroadcast(Settings, v.w));
}
float WaveBroadcast(const FWaveBroadcastSettings Settings, float x)
{
	return asfloat(WaveBroadcast(Settings, asuint(x)));
}
float2 WaveBroadcast(const FWaveBroadcastSettings Settings, float2 v)
{
	return float2(
		WaveBroadcast(Settings, v.x),
		WaveBroadcast(Settings, v.y));
}
float3 WaveBroadcast(const FWaveBroadcastSettings Settings, float3 v)
{
	return float3(
		WaveBroadcast(Settings, v.x),
		WaveBroadcast(Settings, v.y),
		WaveBroadcast(Settings, v.z));
}
float4 WaveBroadcast(const FWaveBroadcastSettings Settings, float4 v)
{
	return float4(
		WaveBroadcast(Settings, v.x),
		WaveBroadcast(Settings, v.y),
		WaveBroadcast(Settings, v.z),
		WaveBroadcast(Settings, v.w));
}
bool WaveBroadcast(const FWaveBroadcastSettings Settings, bool x)
{
	return bool(WaveBroadcast(Settings, uint(x)));
}
bool2 WaveBroadcast(const FWaveBroadcastSettings Settings, bool2 v)
{
	return bool2(
		WaveBroadcast(Settings, v.x),
		WaveBroadcast(Settings, v.y));
}
bool3 WaveBroadcast(const FWaveBroadcastSettings Settings, bool3 v)
{
	return bool3(
		WaveBroadcast(Settings, v.x),
		WaveBroadcast(Settings, v.y),
		WaveBroadcast(Settings, v.z));
}
bool4 WaveBroadcast(const FWaveBroadcastSettings Settings, bool4 v)
{
	return bool4(
		WaveBroadcast(Settings, v.x),
		WaveBroadcast(Settings, v.y),
		WaveBroadcast(Settings, v.z),
		WaveBroadcast(Settings, v.w));
}
FWaveBroadcastSettings InitNopBroadcast()
{
	FWaveBroadcastSettings Settings;
	Settings.Operation  = 0;
	Settings.SourceLaneIndex  = 0;
	Settings.GroupThreadIndex = 0;
	Settings.SwizzleAnd = 0x00;
	Settings.SwizzleOr  = 0x00;
	Settings.SwizzleXor = 0x00;
	Settings.Rotate        = +0;
	Settings.RotateFixMask = 0x00;
	return Settings;
}
FWaveBroadcastSettings InitWaveXorButterfly(const uint XorButterFly)
{
	FWaveBroadcastSettings Settings = InitNopBroadcast();
	Settings.Operation  = 3;
	Settings.SwizzleAnd = 0x1F;
	Settings.SwizzleOr  = 0x00;
	Settings.SwizzleXor = XorButterFly;
	return Settings;
}
FWaveBroadcastSettings InitWaveSwapWithinLaneGroup(const uint LaneGroupSize)
{
	return InitWaveXorButterfly( LaneGroupSize >> 1);
}
void DecompressDevizeZAndN(uint Compressed, out float DevizeZ, out float3 N)
{
	DevizeZ = f16tof32(Compressed & 0x3FFF);
	uint FaceN = (Compressed >> 15) & 0x7;
	N.x = float((Compressed >> 18) & 0x7F) * rcp(127);
	N.y = float((Compressed >> 25) & 0x7F) * rcp(127);
	N.z = 0.0;
	DecodeNormal( N, FaceN);
}
struct FSSDCompressedSceneInfos
{
	uint VGPR[6];
};
FSSDCompressedSceneInfos CreateCompressedSceneInfos()
{
	FSSDCompressedSceneInfos CompressedInfos;
	 [unroll( 6 )]
	for (uint i = 0; i < 6; i++)
	{
		CompressedInfos.VGPR[i] = 0;
	}
	return CompressedInfos;
}
struct FSSDSampleSceneInfos
{
	float2 ScreenPosition;
	float DeviceZ;
	float WorldDepth;
	float Roughness;
	float3 WorldNormal;
	float3 ViewNormal;
	float3 TranslatedWorldPosition;
	uint ShadingModelID;
};
FSSDSampleSceneInfos CreateSampleSceneInfos()
{
	FSSDSampleSceneInfos Infos;
	Infos.WorldDepth              = 0;
	Infos.ScreenPosition          = 0;
	Infos.Roughness               = 0;
	Infos.WorldNormal             = 0;
	Infos.ViewNormal              = 0;
	Infos.TranslatedWorldPosition = 0;
	Infos.ShadingModelID          = 1;
	return Infos;
}
FSSDSampleSceneInfos UncompressSampleSceneInfo(
	const uint CompressedLayout, const bool bIsPrevFrame,
	float2 ScreenPosition,
	FSSDCompressedSceneInfos CompressedInfos)
{
	FSSDSampleSceneInfos Infos = CreateSampleSceneInfos();
	Infos.ScreenPosition = ScreenPosition;
	if (CompressedLayout == 0)
	{
		Infos.WorldDepth = asfloat(CompressedInfos.VGPR[0]);
		Infos.WorldNormal.x = asfloat(CompressedInfos.VGPR[1]);
		Infos.WorldNormal.y = asfloat(CompressedInfos.VGPR[2]);
		Infos.WorldNormal.z = asfloat(CompressedInfos.VGPR[3]);
		Infos.Roughness = asfloat(CompressedInfos.VGPR[4]);
		Infos.ShadingModelID = CompressedInfos.VGPR[5];
		Infos.DeviceZ = ConvertToDeviceZ(Infos.WorldDepth);
		Infos.ViewNormal = mul(float4(Infos.WorldNormal, 0), View.TranslatedWorldToView).xyz;
	}
	else if (CompressedLayout == 1)
	{
		DecompressDevizeZAndN(CompressedInfos.VGPR[0],  Infos.DeviceZ,  Infos.WorldNormal);
		Infos.WorldDepth = ConvertFromDeviceZ(Infos.DeviceZ);
		Infos.ViewNormal = mul(float4(Infos.WorldNormal, 0), View.TranslatedWorldToView).xyz;
	}
	else if (CompressedLayout == 2)
	{
		float3 DecodedViewNormal;
		DecompressDevizeZAndN(CompressedInfos.VGPR[0],  Infos.DeviceZ,  DecodedViewNormal);
		Infos.WorldDepth = ConvertFromDeviceZ(Infos.DeviceZ);
		if (bIsPrevFrame)
		{
			Infos.WorldNormal = mul(float4(DecodedViewNormal, 0), View.PrevViewToTranslatedWorld).xyz;
			Infos.ViewNormal = mul(float4(Infos.WorldNormal, 0), View.TranslatedWorldToView).xyz;	
		}
		else
		{
			Infos.ViewNormal = DecodedViewNormal;
			Infos.WorldNormal = mul(float4(Infos.ViewNormal, 0), View.ViewToTranslatedWorld).xyz;
		}
	}
	else if (CompressedLayout == 3)
	{
		Infos.DeviceZ = asfloat(CompressedInfos.VGPR[0]);
		Infos.WorldDepth = ConvertFromDeviceZ(Infos.DeviceZ);
		Infos.ShadingModelID = CompressedInfos.VGPR[1];
	}
	else if (CompressedLayout == 4)
	{
		Infos.TranslatedWorldPosition.x = asfloat(CompressedInfos.VGPR[0]);
		Infos.TranslatedWorldPosition.y = asfloat(CompressedInfos.VGPR[1]);
		Infos.TranslatedWorldPosition.z = asfloat(CompressedInfos.VGPR[2]);
		Infos.ShadingModelID = CompressedInfos.VGPR[3];
		if (bIsPrevFrame)
		{
			Infos.WorldDepth = mul(float4(Infos.TranslatedWorldPosition, 1.0), View.TranslatedWorldToView).z;
		}
		else
		{
			Infos.WorldDepth = mul(float4(Infos.TranslatedWorldPosition, 1.0), View.PrevTranslatedWorldToView).z;
		}
		Infos.DeviceZ = ConvertToDeviceZ(Infos.WorldDepth);
		return Infos;
	}
	else
	{
	}
	{
		float4 ClipPosition = float4(GetScreenPositionForProjectionType(ScreenPosition, Infos.WorldDepth), Infos.WorldDepth, 1);
		if (bIsPrevFrame)
		{
			float3 PreViewTranslationOffset = DFFastLocalSubtractDemote(GetPrimaryView().PreViewTranslation, GetPrimaryView().PrevPreViewTranslation);
			Infos.TranslatedWorldPosition = mul(ClipPosition, View.PrevScreenToTranslatedWorld).xyz + PreViewTranslationOffset;
		}
		else
		{
			Infos.TranslatedWorldPosition = mul(ClipPosition, View.ScreenToTranslatedWorld).xyz;
		}
	}
	return Infos;
}
float3 GetWorldNormal(FSSDSampleSceneInfos SceneMetadata)
{
	return SceneMetadata.WorldNormal;
}
float GetWorldDepth(FSSDSampleSceneInfos SceneMetadata)
{
	return SceneMetadata.WorldDepth;
}
float3 GetTranslatedWorldPosition(FSSDSampleSceneInfos SceneMetadata)
{
	return SceneMetadata.TranslatedWorldPosition;
}
FSSDSampleSceneInfos WaveBroadcastSceneMetadata(const FWaveBroadcastSettings Settings, FSSDSampleSceneInfos SceneMetadata)
{
	FSSDSampleSceneInfos NewSceneMetadata;
	NewSceneMetadata.WorldDepth              = WaveBroadcast(Settings, SceneMetadata.WorldDepth);
	NewSceneMetadata.ScreenPosition          = WaveBroadcast(Settings, SceneMetadata.ScreenPosition);
	NewSceneMetadata.Roughness               = WaveBroadcast(Settings, SceneMetadata.Roughness);
	NewSceneMetadata.WorldNormal             = WaveBroadcast(Settings, SceneMetadata.WorldNormal);
	NewSceneMetadata.ViewNormal              = WaveBroadcast(Settings, SceneMetadata.ViewNormal);
	NewSceneMetadata.TranslatedWorldPosition = WaveBroadcast(Settings, SceneMetadata.TranslatedWorldPosition);
	return NewSceneMetadata;
}
uint2 ViewportMax;
float4 ThreadIdToBufferUV;
float4 DenoiserBufferSizeAndInvSize;
float4 DenoiserBufferBilinearUVMinMax;
float2 BufferUVToOutputPixelPosition;
float4 SceneBufferUVToScreenPosition;
float2 BufferUVBilinearCorrection;
float4 PrevSceneBufferUVToScreenPosition;
Texture2D PrevDepthBuffer;
Texture2D PrevGBufferA;
Texture2D PrevGBufferB;
float SafeRcp(float x)
{
	if (x > 0)
		return rcp(x);
	return 0;
}
float ComputeAnisotropyInvFactor(FSSDSampleSceneInfos SceneMetadata)
{
	if (!0)
	{
		return 1;
	}
	float Anysotropy = abs(dot(GetWorldNormal(SceneMetadata), View.ViewForward));
	return max(Anysotropy, rcp(8));
}
float ComputeWorldBluringRadiusCausedByPixelSize(FSSDSampleSceneInfos SceneMetadata)
{
	return GetDepthPixelRadiusForProjectionType(GetWorldDepth(SceneMetadata));
}
float WorldBluringRadiusToBilateralWorldDistance(float WorldBluringRadius)
{
	float Multiplier = 1;
	Multiplier *= 2;
	Multiplier *= sqrt(2);
	Multiplier *= 3.0;
	return WorldBluringRadius * Multiplier;
}
uint2 BufferUVToBufferPixelCoord(float2 SceneBufferUV)
{
	return uint2(SceneBufferUV * BufferUVToOutputPixelPosition);
}
float2 DenoiserBufferUVToScreenPosition(float2 SceneBufferUV)
{
	return SceneBufferUV * SceneBufferUVToScreenPosition.xy + SceneBufferUVToScreenPosition.zw;
}
FSSDCompressedSceneInfos MaterialToCompressedSceneMetadata(float Depth, float3 WorldNormal, float Roughness, uint ShadingID)
{
	FSSDCompressedSceneInfos CompressedMetadata = CreateCompressedSceneInfos();
	CompressedMetadata.VGPR[0] = asuint(Depth);
	CompressedMetadata.VGPR[1] = asuint(WorldNormal.x);
	CompressedMetadata.VGPR[2] = asuint(WorldNormal.y);
	CompressedMetadata.VGPR[3] = asuint(WorldNormal.z);
	CompressedMetadata.VGPR[4] = asuint(Roughness);
	CompressedMetadata.VGPR[5] = ShadingID;
	return CompressedMetadata;
}
FSSDCompressedSceneInfos SampleCompressedSceneMetadata(
	const bool bPrevFrame,
	float2 BufferUV, uint2 PixelCoord)
{
	FGBufferData GBufferData;
	if (bPrevFrame)
	{
		float DeviceZ = PrevDepthBuffer.SampleLevel( D3DStaticPointClampedSampler, BufferUV, 0).r;
		uint CustomStencil = 0;
		float CustomNativeDepth = 0;
		float SceneDepth = ConvertFromDeviceZ(DeviceZ);
		float4 GBufferA = PrevGBufferA.SampleLevel( D3DStaticPointClampedSampler, BufferUV, 0);
		float4 GBufferB = PrevGBufferB.SampleLevel( D3DStaticPointClampedSampler, BufferUV, 0);
		float4 GBufferC = 0.0;
		float4 GBufferD = 0.0;
		float4 GBufferE = 0.0;
		float4 GBufferF = 0.5f;
		float4 GBufferVelocity = 0.0;
		bool bGetNormalizedNormal = false;
		GBufferData = DecodeGBufferData(
			GBufferA, GBufferB, GBufferC, GBufferD, GBufferE, GBufferF, GBufferVelocity,
			CustomNativeDepth, CustomStencil, SceneDepth, bGetNormalizedNormal, CheckerFromSceneColorUV(BufferUV));
	}
	else
	{
		GBufferData = GetGBufferDataFromSceneTextures(BufferUV);	
	}
	return MaterialToCompressedSceneMetadata(GBufferData.Depth, GBufferData.WorldNormal, GBufferData.Roughness, GBufferData.ShadingModelID);
}
struct FSSDSignalSample
{
	float SampleCount;
		float4 SceneColor;
	float MissCount;
	float TransmissionDistance;
};
struct FSSDSignalFrequency
{
	float ClosestHitDistance;
	float WorldBluringRadius;
	float ConfusionFactor;
};
struct FSSDSignalArray
{
	FSSDSignalSample Array[1];
};
struct FSSDSignalFrequencyArray
{
	FSSDSignalFrequency Array[1];
};
FSSDSignalSample CreateSignalSampleFromScalarValue(float Scalar)
{
	FSSDSignalSample OutSample;
		OutSample.SceneColor = Scalar;
	OutSample.SampleCount = Scalar;
	OutSample.MissCount = Scalar;
	OutSample.TransmissionDistance = Scalar;
	return OutSample;
}
FSSDSignalFrequency CreateInvalidSignalFrequency()
{
	FSSDSignalFrequency Frequency;
	Frequency.ClosestHitDistance = -2.0;
	Frequency.WorldBluringRadius = -1;
	Frequency.ConfusionFactor = -1;
	return Frequency;
}
FSSDSignalArray CreateSignalArrayFromScalarValue(float Scalar)
{
	FSSDSignalArray OutSamples;
	 [unroll( 1 )]
	for (uint BatchedSignalId = 0; BatchedSignalId < 1; BatchedSignalId++)
	{
		OutSamples.Array[BatchedSignalId] = CreateSignalSampleFromScalarValue(Scalar);
	}
	return OutSamples;
}
FSSDSignalFrequencyArray CreateInvalidSignalFrequencyArray()
{
	FSSDSignalFrequencyArray OutFrequencies;
	 [unroll( 1 )]
	for (uint BatchedSignalId = 0; BatchedSignalId < 1; BatchedSignalId++)
	{
		OutFrequencies.Array[BatchedSignalId] = CreateInvalidSignalFrequency();
	}
	return OutFrequencies;
}
FSSDSignalSample MulSignal(FSSDSignalSample Sample, float Scalar)
{
	FSSDSignalSample OutSample;
		OutSample.SceneColor         = Sample.SceneColor * Scalar;
	OutSample.SampleCount            = Sample.SampleCount * Scalar;
	OutSample.MissCount              = Sample.MissCount * Scalar;
	OutSample.TransmissionDistance   = Sample.TransmissionDistance * Scalar;
	return OutSample;
}
FSSDSignalSample AddSignal(FSSDSignalSample SampleA, FSSDSignalSample SampleB)
{
		SampleA.SceneColor         += SampleB.SceneColor;
	SampleA.SampleCount            += SampleB.SampleCount;
	SampleA.MissCount              += SampleB.MissCount;
	SampleA.TransmissionDistance   += SampleB.TransmissionDistance;
	return SampleA;
}
FSSDSignalSample MinSignal(FSSDSignalSample SampleA, FSSDSignalSample SampleB)
{
	FSSDSignalSample OutSample;
		OutSample.SceneColor = min(SampleA.SceneColor, SampleB.SceneColor);
	OutSample.SampleCount = min(SampleA.SampleCount, SampleB.SampleCount);
	OutSample.MissCount = min(SampleA.MissCount, SampleB.MissCount);
	OutSample.TransmissionDistance = min(SampleA.TransmissionDistance, SampleB.TransmissionDistance);
	return OutSample;
}
FSSDSignalSample MaxSignal(FSSDSignalSample SampleA, FSSDSignalSample SampleB)
{
	FSSDSignalSample OutSample;
		OutSample.SceneColor = max(SampleA.SceneColor, SampleB.SceneColor);
	OutSample.SampleCount = max(SampleA.SampleCount, SampleB.SampleCount);
	OutSample.MissCount = max(SampleA.MissCount, SampleB.MissCount);
	OutSample.TransmissionDistance = max(SampleA.TransmissionDistance, SampleB.TransmissionDistance);
	return OutSample;
}
FSSDSignalSample ClampSignal(FSSDSignalSample Sample, FSSDSignalSample SampleMin, FSSDSignalSample SampleMax)
{
	FSSDSignalSample OutSample;
		OutSample.SceneColor = clamp(Sample.SceneColor, SampleMin.SceneColor, SampleMax.SceneColor);
	OutSample.SampleCount = clamp(Sample.SampleCount, SampleMin.SampleCount, SampleMax.SampleCount);
	OutSample.MissCount = clamp(Sample.MissCount, SampleMin.MissCount, SampleMax.MissCount);
	OutSample.TransmissionDistance = clamp(Sample.TransmissionDistance, SampleMin.TransmissionDistance, SampleMax.TransmissionDistance);
	return OutSample;
}
FSSDSignalSample NormalizeToOneSample(FSSDSignalSample Sample)
{
	FSSDSignalSample OutSample = MulSignal(Sample, Sample.SampleCount > 0 ? rcp(Sample.SampleCount) : 0);
	OutSample.SampleCount = Sample.SampleCount > 0 ? 1 : 0;
	return OutSample;
}
FSSDSignalSample WaveBroadcastSignal(const FWaveBroadcastSettings BroadcastSettings, FSSDSignalSample Sample)
{
	FSSDSignalSample OutSample;
		OutSample.SceneColor = WaveBroadcast(BroadcastSettings, Sample.SceneColor);
	OutSample.SampleCount        = WaveBroadcast(BroadcastSettings, Sample.SampleCount);
	OutSample.MissCount          = WaveBroadcast(BroadcastSettings, Sample.MissCount);
	OutSample.TransmissionDistance = WaveBroadcast(BroadcastSettings, Sample.TransmissionDistance);
	return OutSample;
}
FSSDSignalFrequency MinSignalFrequency(FSSDSignalFrequency FrequencyA, FSSDSignalFrequency FrequencyB)
{
	FSSDSignalFrequency OutFrequency;
	OutFrequency.ClosestHitDistance = min(FrequencyA.ClosestHitDistance, FrequencyB.ClosestHitDistance);
	OutFrequency.WorldBluringRadius = min(FrequencyA.WorldBluringRadius, FrequencyB.WorldBluringRadius);
	OutFrequency.ConfusionFactor = min(FrequencyA.ConfusionFactor, FrequencyB.ConfusionFactor);
	return OutFrequency;
}
FSSDSignalFrequency WaveBroadcastSignalFrequency(const FWaveBroadcastSettings BroadcastSettings, FSSDSignalFrequency Frequency)
{
	FSSDSignalFrequency OutFrequency;
	OutFrequency.ClosestHitDistance = WaveBroadcast(BroadcastSettings, Frequency.ClosestHitDistance);
	OutFrequency.WorldBluringRadius = WaveBroadcast(BroadcastSettings, Frequency.WorldBluringRadius);
	OutFrequency.ConfusionFactor = WaveBroadcast(BroadcastSettings, Frequency.ConfusionFactor);
	return OutFrequency;
}
StructuredBuffer<float4> EyeAdaptationBuffer;
float4 EyeAdaptationLookupBuffer(StructuredBuffer<float4> InEyeAdaptation)
{
	return InEyeAdaptation[0];
}
float EyeAdaptationLookup()
{
	return EyeAdaptationLookupBuffer(EyeAdaptationBuffer).x;
}
struct FLightShaderParameters
{
	float3 TranslatedWorldPosition;
	float  InvRadius;
	float3 Color;
	float  FalloffExponent;
	float3 Direction;
	float3 Tangent;
	float2 SpotAngles;
	float  SpecularScale;
	float  SourceRadius;
	float  SoftSourceRadius;
	float  SourceLength;
	float  RectLightBarnCosAngle;
	float  RectLightBarnLength;
	float2 RectLightAtlasUVOffset;
	float2 RectLightAtlasUVScale;
	float  RectLightAtlasMaxLevel;
	float  IESAtlasIndex;
	uint  LightFunctionAtlasLightIndex;
};
struct FSSDSignalDomainKnowledge
{
	FLightShaderParameters Light;
	float HitDistanceToWorldBluringRadius;
	uint LightType;
};
float4 LightPositionAndRadius[1];
float4 LightDirectionAndLength[1];
float4 HitDistanceToWorldBluringRadius [ (( 1 +3)/4)];
uint4 LightType [ (( 1 +3)/4)];
FSSDSignalDomainKnowledge GetSignalDomainKnowledge(uint BatchedSignalId)
{
	FSSDSignalDomainKnowledge SignalDomain;
	SignalDomain.Light.InvRadius = 0;
	SignalDomain.Light.Color = 0;
	SignalDomain.Light.FalloffExponent = 0;
	SignalDomain.Light.Tangent = 0;
	SignalDomain.Light.SpotAngles = 0;
	SignalDomain.Light.SpecularScale = 0;
	SignalDomain.Light.SoftSourceRadius = 0;	
	SignalDomain.Light.TranslatedWorldPosition = LightPositionAndRadius[BatchedSignalId].xyz;
	SignalDomain.Light.Direction = LightDirectionAndLength[BatchedSignalId].xyz;
	SignalDomain.Light.SourceRadius = LightPositionAndRadius[BatchedSignalId].w;
	SignalDomain.Light.SourceLength = LightDirectionAndLength[BatchedSignalId].w;
	SignalDomain.HitDistanceToWorldBluringRadius =   HitDistanceToWorldBluringRadius [(uint) BatchedSignalId >>2u][(uint) BatchedSignalId &3u];
	{
		SignalDomain.LightType =   LightType [(uint) BatchedSignalId >>2u][(uint) BatchedSignalId &3u];
	}
	return SignalDomain;
}
float Luma4(float3 Color)
{
	return (Color.g * 2.0) + (Color.r + Color.b);
}
float KarisHdrWeightY(float Color, float Exposure) 
{
	return rcp(Color * Exposure + 4.0);
}
float KarisHdrWeightInvY(float Color, float Exposure) 
{
	return 4.0 * rcp(1.0 - Color * Exposure);
}
float GetSignalColorTransformationExposure()
{
	const float Tweak = 1;
	float FrameExposureScale = EyeAdaptationLookup();
	FrameExposureScale *= View.OneOverPreExposure;
	return  WaveReadLaneFirst( FrameExposureScale * Tweak );
}
FSSDSignalSample TransformSignal(FSSDSignalSample Sample, const uint SrcBasis, const uint DestBasis)
{
	if (SrcBasis == DestBasis)
	{
		return Sample;
	}
	float FrameExposureScale = GetSignalColorTransformationExposure();
	const bool bIsNormalizedSample = false;
	const bool bDebugForceNormalizeColor = true;
	const bool bIsNormalizedColor = bIsNormalizedSample || bDebugForceNormalizeColor;
	const bool bUnchangeAlphaPremultiply = (SrcBasis & 0x4) == (DestBasis & 0x4);
	const bool bUnchangeColorSpace = bUnchangeAlphaPremultiply && (SrcBasis & 0x3) == (DestBasis & 0x3);
	if (bDebugForceNormalizeColor)
	{
		Sample.SceneColor *= SafeRcp(Sample.SampleCount);
	}
	if (SrcBasis & 0x8)
	{
		float KarisX = Luma4(Sample.SceneColor.rgb);
		if ((SrcBasis & 0x3))
		{
			KarisX = Sample.SceneColor.x;
		}
		if (!bIsNormalizedColor)
		{
			KarisX *= SafeRcp(Sample.SampleCount);
		}
		Sample.SceneColor *= KarisHdrWeightInvY(KarisX, FrameExposureScale);
	}
	if (bUnchangeColorSpace)
	{
	}
	else if ((SrcBasis & 0x3) == 0x1)
	{
		Sample.SceneColor.rgb = YCoCg_2_LinearRGB(Sample.SceneColor.rgb);
	}
	else if ((SrcBasis & 0x3) == 0x2)
	{
		Sample.SceneColor.rgb = LCoCg_2_LinearRGB(Sample.SceneColor.rgb);
	}
	float Alpha = Sample.SceneColor.a * SafeRcp(Sample.SampleCount);
	if (bIsNormalizedColor)
	{
		Alpha = Sample.SceneColor.a;
	}
	if (bUnchangeAlphaPremultiply)
	{
	}
	else if (SrcBasis & 0x4)
	{
		Sample.SceneColor.rgb *= Alpha;
	}
	else 
	{
		Sample.SceneColor.rgb *= SafeRcp(Alpha);
	}
	float x = Luma4(Sample.SceneColor.rgb);
	if ((DestBasis & 0x3) == 0x1)
	{
		if (!bUnchangeColorSpace)
			Sample.SceneColor.xyz = LinearRGB_2_YCoCg(Sample.SceneColor.rgb);
		x = Sample.SceneColor.x;
	}
	else if ((DestBasis & 0x3) == 0x2)
	{
		if (!bUnchangeColorSpace)
			Sample.SceneColor.xyz = LinearRGB_2_LCoCg(Sample.SceneColor.rgb);
		x = Sample.SceneColor.x;
	}
	if (DestBasis & 0x8)
	{
		if (bIsNormalizedColor)
		{
			Sample.SceneColor *= KarisHdrWeightY(x, FrameExposureScale);
		}
		else
		{
			Sample.SceneColor *= KarisHdrWeightY(x * SafeRcp(Sample.SampleCount), FrameExposureScale);
		}
	}
	if (bDebugForceNormalizeColor)
	{
		Sample.SceneColor *= Sample.SampleCount;
	}
	return Sample;
}
FSphericalGaussian ComputeRoughnessLobe(float Roughness, float3 N, float3 V)
{
	float a = Pow2( max( 0.001, Roughness ) );
	float a2 = a*a;
	float NoV = saturate( abs( dot(N, V) ) + 1e-5 );
	float3 R = 2 * NoV * N - V;
	FSphericalGaussian SpecularSG;
	SpecularSG.Axis = R;
	SpecularSG.Sharpness = 0.5 / ( a2 * max( NoV, 0.1 ) );
	SpecularSG.Amplitude = rcp( PI * a2 );
	return SpecularSG;
}
FSphericalGaussian ComputeRoughnessLobe(FSSDSampleSceneInfos RefSceneMetadata)
{
		float3 N = RefSceneMetadata.WorldNormal;
		float3 V = -GetCameraVectorFromTranslatedWorldPosition(GetTranslatedWorldPosition(RefSceneMetadata));
	float Roughness = RefSceneMetadata.Roughness;
	return ComputeRoughnessLobe(Roughness, N, V);
}
float3 ComputeMajorLightRayDirection(FSSDSampleSceneInfos SceneMetadata, FSSDSignalDomainKnowledge DomainKnowledge)
{
	return float3(0.0, 0.0, 1.0);
}
float ComputeLightSourceRadius(FSSDSignalDomainKnowledge DomainKnowledge)
{
	return 0.0f;
}
float ComputeBilateralWeight(
	const uint BilateralSettings,
	float MaxWorldBluringDistance,
	FSSDSignalDomainKnowledge DomainKnowledge,
	FSSDSampleSceneInfos RefSceneMetadata,
	FSSDSampleSceneInfos NeighborSceneMetadata,
	float3 NeighborToRefVector)
{
	if (0)
	{
		return 1;
	}
		float3 RefNormal = RefSceneMetadata.WorldNormal;
		float3 NeighborNormal = NeighborSceneMetadata.WorldNormal;
	float InvMaxWorldBluringDistance = rcp(MaxWorldBluringDistance);
	float PositionBilateralWeight = 1;
	if ((BilateralSettings & 0xF) == 1)
	{
		const float WorldRadius = MaxWorldBluringDistance;
		float RefAnisotropyInvFactor = ComputeAnisotropyInvFactor(RefSceneMetadata);
		float3 CameraToRef = View.ViewForward;
		float Z = dot(CameraToRef, NeighborToRefVector);
		float XY = length2(NeighborToRefVector - CameraToRef * Z * (1 - RefAnisotropyInvFactor));
		float DistSquare = XY;
		float Multiplier = rcp(WorldRadius * WorldRadius);
		PositionBilateralWeight = saturate(1 - DistSquare * Multiplier);
	}
	else if ((BilateralSettings & 0xF) == 2)
	{
		float DistFromRefPlane = abs(dot(RefNormal, NeighborToRefVector));
		PositionBilateralWeight = saturate(1 - DistFromRefPlane * InvMaxWorldBluringDistance);
	}
	else if ((BilateralSettings & 0xF) == 3)
	{
		if (dot(NeighborToRefVector, NeighborToRefVector) > MaxWorldBluringDistance * MaxWorldBluringDistance)
		{
			PositionBilateralWeight = 0;
		}
	}
	else if ((BilateralSettings & 0xF) == 4)
	{
		PositionBilateralWeight = saturate(1 - dot(NeighborToRefVector, NeighborToRefVector) * rcp(MaxWorldBluringDistance * MaxWorldBluringDistance));
	}
	else if ((BilateralSettings & 0xF) == 5)
	{
		float LightTangentBilateral;
		{
			float3 NeighborToLight = ComputeMajorLightRayDirection(NeighborSceneMetadata, DomainKnowledge);
			float3 ProjectedNeighborToRefVector = NeighborToRefVector - NeighborToLight * dot(NeighborToLight, NeighborToRefVector);
			LightTangentBilateral = saturate(1 - dot(ProjectedNeighborToRefVector, ProjectedNeighborToRefVector) * (InvMaxWorldBluringDistance * InvMaxWorldBluringDistance));
		}
		float PlaneMisAlignementBilateral;
		{
			const bool bApplyDepthPenaltyWeightForSSS = RefSceneMetadata.ShadingModelID == 5 && ComputeLightSourceRadius(DomainKnowledge) > 0.0f;
			const float	NormalEncodingError = bApplyDepthPenaltyWeightForSSS ? DomainKnowledge.Light.SourceRadius : -0.25;
			float DistFromRefPlane = dot(RefNormal, -NeighborToRefVector);
			float NeighborToRefPlaneDistance = length(-NeighborToRefVector - DistFromRefPlane * RefNormal);
			float NeighborToRefError = NeighborToRefPlaneDistance * NormalEncodingError;
			PlaneMisAlignementBilateral = saturate(1 - 6 * (abs(DistFromRefPlane) + NeighborToRefError) * InvMaxWorldBluringDistance);
		}
		PositionBilateralWeight = LightTangentBilateral * PlaneMisAlignementBilateral;
	}
	else if ((BilateralSettings & 0xF) == 6)
	{
		float PlaneMisAlignementBilateral;
		{
			const float NormalEncodingError = View.GeneralPurposeTweak;
			float DistFromRefPlane = dot(RefNormal, -NeighborToRefVector);
			float NeighborToRefPlaneDistance = length(-NeighborToRefVector - DistFromRefPlane * RefNormal);
			float NeighborToRefError = NeighborToRefPlaneDistance * NormalEncodingError;
			PlaneMisAlignementBilateral = saturate(1 - (abs(DistFromRefPlane) - NeighborToRefError) * InvMaxWorldBluringDistance);
		}
		PositionBilateralWeight = PlaneMisAlignementBilateral;
	}
	float NormalBilateralWeight = 1;
	if (BilateralSettings & 0x0010)
	{
		float NoN = max(dot(RefNormal, NeighborNormal), 0);
			NormalBilateralWeight = pow(NoN, 4);
	}
	float LobeSimilarity = 1;
	float AxesSimilarity = 1;
	if (BilateralSettings & (0x0020 | 0x0040))
	{
		const float Beta = 32;
		FSphericalGaussian Ref = ComputeRoughnessLobe(RefSceneMetadata);
		FSphericalGaussian Neighbor = ComputeRoughnessLobe(NeighborSceneMetadata);
		float InvSharpnessSum = rcp(Ref.Sharpness + Neighbor.Sharpness);
		if (BilateralSettings & 0x0020)
			LobeSimilarity = pow(2 * sqrt(Ref.Sharpness * Neighbor.Sharpness) * InvSharpnessSum, Beta);
		if (BilateralSettings & 0x0040)
			AxesSimilarity = exp(-(Beta * (Ref.Sharpness * Neighbor.Sharpness) * InvSharpnessSum) * saturate(1 - dot(Ref.Axis, Neighbor.Axis)));
	}
	if (BilateralSettings & 0x0080)
	{
		[flatten]
		if (RefSceneMetadata.ShadingModelID != NeighborSceneMetadata.ShadingModelID)
			return 0.0;
	}
	return PositionBilateralWeight * NormalBilateralWeight * LobeSimilarity * AxesSimilarity;
}
float GetSignalWorldBluringRadius(FSSDSignalFrequency SampleFrequency, FSSDSampleSceneInfos SceneMetadata, FSSDSignalDomainKnowledge DomainKnowledge)
{
	if (SampleFrequency.ClosestHitDistance == -2.0)
	{
		return -1;
	}
	else if (SampleFrequency.ClosestHitDistance == -1.0)
	{
		return (100000); 
	}
	return SampleFrequency.ClosestHitDistance;
}
FSSDSignalArray NormalizeToOneSampleArray(FSSDSignalArray Samples)
{
	FSSDSignalArray OutSamples;
	 [unroll( 1 )]
	for (uint BatchedSignalId = 0; BatchedSignalId < 1; BatchedSignalId++)
	{
		OutSamples.Array[BatchedSignalId] = NormalizeToOneSample(Samples.Array[BatchedSignalId]);
	}
	return OutSamples;
}
FSSDSignalArray WaveBroadcastSignalArray(const FWaveBroadcastSettings BroadcastSettings, FSSDSignalArray Samples)
{
	FSSDSignalArray OutSamples;
	 [unroll( 1 )]
	for (uint BatchedSignalId = 0; BatchedSignalId < 1; BatchedSignalId++)
	{
		OutSamples.Array[BatchedSignalId] = WaveBroadcastSignal(BroadcastSettings, Samples.Array[BatchedSignalId]);
	}
	return OutSamples;
}
FSSDSignalFrequencyArray WaveBroadcastSignalFrequenciesArray(const FWaveBroadcastSettings BroadcastSettings, FSSDSignalFrequencyArray Frequencies)
{
	FSSDSignalFrequencyArray OutFrequencies;
	 [unroll( 1 )]
	for (uint BatchedSignalId = 0; BatchedSignalId < 1; BatchedSignalId++)
	{
		OutFrequencies.Array[BatchedSignalId] = WaveBroadcastSignalFrequency(BroadcastSettings, Frequencies.Array[BatchedSignalId]);
	}
	return OutFrequencies;
}
struct FSSDCompressedSignalSample
{
	uint VGPR[1];
};
void CompressSignalSample(in FSSDSignalSample Sample, uint CompressionLayout, out FSSDCompressedSignalSample OutCompressedSample)
{
	 [unroll( 1 )]
	for (uint i = 0; i < 1; i++)
	{
		OutCompressedSample.VGPR[i] = 0;
	}
	if (CompressionLayout == 0 || 0)
	{
	}
}
void UncompressSignalSample(in FSSDCompressedSignalSample CompressedSample, uint CompressionLayout, inout FSSDSignalSample OutSample)
{
	if (CompressionLayout == 0 || 0)
	{
	}
}
FSSDCompressedSignalSample CreateCompressedSignalSampleFromScalarValue(float Scalar, uint CompressionLayout)
{
	FSSDSignalSample Sample = CreateSignalSampleFromScalarValue(Scalar);
	FSSDCompressedSignalSample CompressedSample;
	CompressSignalSample(Sample, CompressionLayout,  CompressedSample);
	return CompressedSample;
}
struct FSSDSignalAccumulator
{
		FSSDSignalSample Moment1;
		FSSDCompressedSignalSample CompressedMoment1;
		FSSDSignalSample Min;
		FSSDSignalSample Max;
		FSSDSignalFrequency MinFrequency;
};
struct FSSDSampleClusterInfo
{
	float OutterBoundaryRadius;
};
FSSDSignalAccumulator CreateSignalAccumulator()
{
	FSSDSignalAccumulator Accumulator;
		Accumulator.Moment1 = CreateSignalSampleFromScalarValue(0.0);
		Accumulator.CompressedMoment1 = CreateCompressedSignalSampleFromScalarValue(0.0, 0);
		Accumulator.Min = CreateSignalSampleFromScalarValue(1.#INF);
		Accumulator.Max = CreateSignalSampleFromScalarValue(0.0); 
		Accumulator.MinFrequency.ClosestHitDistance = 1.#INF;
		Accumulator.MinFrequency.WorldBluringRadius = (100000);
		Accumulator.MinFrequency.ConfusionFactor = 1;
	return Accumulator;
}
struct FSSDSampleAccumulationInfos
{
	FSSDSignalSample Sample;
	FSSDSignalFrequency Frequency;
	float FinalWeight;
	float InvFrequency;
};
float AmendWorldBluringRadiusCausedByPixelSize(float WorldBluringDistance)
{
	float Multiplier = 1;
	Multiplier *= 2;
	Multiplier *= sqrt(2);
	return WorldBluringDistance * Multiplier;
}
void AccumulateSampleInOneBin(inout FSSDSignalAccumulator Accumulator, FSSDSampleAccumulationInfos SampleInfos)
{
	float SampleWeight = SampleInfos.FinalWeight;
		Accumulator.Moment1 = AddSignal(Accumulator.Moment1, MulSignal(SampleInfos.Sample, SampleWeight));
}
void AccumulateSampleInDomainBoundaries(inout FSSDSignalAccumulator Accumulator, FSSDSampleAccumulationInfos SampleInfos)
{
	[flatten]
	if (SampleInfos.FinalWeight > 0)
	{
		{
			Accumulator.Min = MinSignal(Accumulator.Min, SampleInfos.Sample);
			Accumulator.Max = MaxSignal(Accumulator.Max, SampleInfos.Sample);
		}
		if (SampleInfos.InvFrequency != -1)
		{
			Accumulator.MinFrequency = MinSignalFrequency(Accumulator.MinFrequency, SampleInfos.Frequency);
		}
	}
}
void CompressSignalAccumulator(inout FSSDSignalAccumulator Accumulator)
{
		CompressSignalSample(Accumulator.Moment1, 0,  Accumulator.CompressedMoment1);
}
void UncompressSignalAccumulator(inout FSSDSignalAccumulator Accumulator)
{
		UncompressSignalSample(Accumulator.CompressedMoment1, 0,  Accumulator.Moment1);
}
void StartAccumulatingCluster(
	FSSDSampleSceneInfos RefSceneMetadata,
	inout FSSDSignalAccumulator Accumulator,
	FSSDSampleClusterInfo ClusterInfo)
{
}
void AccumulateSample(
	inout FSSDSignalAccumulator Accumulator,
	FSSDSampleAccumulationInfos SampleInfos)
{
	UncompressSignalAccumulator( Accumulator);
	AccumulateSampleInOneBin( Accumulator, SampleInfos);
	AccumulateSampleInDomainBoundaries( Accumulator, SampleInfos);
	CompressSignalAccumulator( Accumulator);
}
void DijestAccumulatedClusterSamples(
	inout FSSDSignalAccumulator Accumulator,
	uint RingId, uint SampleCount)
{
}
struct FSSDSignalAccumulatorArray
{
	FSSDSignalAccumulator Array[1];
};
struct FSSDCompressedSignalAccumulatorArray
{
	uint VGPR[20];
};
FSSDSignalAccumulatorArray CreateSignalAccumulatorArray()
{
	FSSDSignalAccumulatorArray Accumulators;
	 [unroll( 1 )]
	for (uint i = 0; i < 1; i++)
	{
		Accumulators.Array[i] = CreateSignalAccumulator();
	}
	return Accumulators;
}
FSSDCompressedSignalAccumulatorArray CreateUninitialisedCompressedAccumulatorArray()
{
	FSSDCompressedSignalAccumulatorArray CompressedAccumulators;
	 [unroll( 20 )]
	for (uint i = 0; i < 20; i++)
	{
		CompressedAccumulators.VGPR[i] = 0;
	}
	return CompressedAccumulators;
}
float3 ClampColorForEncoding(float3 Color)
{
		Color = min(Color, MaxHalfFloat);
	return Color;
}
float4 ClampColorForEncoding(float4 Color)
{
	return float4(ClampColorForEncoding(Color.rgb), Color.a);
}
struct FSSDCompressedMultiplexedSample
{
	float4 VGPRArray[4];
};
void DecodeMultiplexedSignalsFromFloat4(
	const uint SignalBufferLayout,
	const uint MultiplexedSampleId,
	const bool bNormalizeSample,
	float4 RawSample[4],
	out FSSDSignalArray OutSamples,
	out FSSDSignalFrequencyArray OutSampleFrequencies)
{
	OutSamples = CreateSignalArrayFromScalarValue(0.0);
	OutSampleFrequencies = CreateInvalidSignalFrequencyArray();
	if (0)
	{
	}
	else if (SignalBufferLayout == 0xDEAD)
	{
		OutSamples = CreateSignalArrayFromScalarValue(-1.#INF);
	}
	else if (SignalBufferLayout == 15)
	{
		 [unroll( 1 )]
		for (uint BatchSignalId = 0; BatchSignalId < 1; BatchSignalId++)
		{
			uint MultiplexId = BatchSignalId;
			OutSamples.Array[MultiplexId].SampleCount = (RawSample[MultiplexId].g == -2.0 ? 0.0 : 1.0);
			OutSamples.Array[MultiplexId].MissCount = OutSamples.Array[MultiplexId].SampleCount * RawSample[MultiplexId].r;
			OutSamples.Array[MultiplexId].TransmissionDistance = OutSamples.Array[MultiplexId].SampleCount * RawSample[MultiplexId].a;
			OutSampleFrequencies.Array[MultiplexId].ClosestHitDistance = RawSample[MultiplexId].g;
			[flatten]
			if (OutSamples.Array[MultiplexId].SampleCount == 0)
			{
				OutSampleFrequencies.Array[MultiplexId].ClosestHitDistance = -2.0;
			}
			else if (OutSamples.Array[MultiplexId].MissCount > 0.999)
			{
				OutSampleFrequencies.Array[MultiplexId].ClosestHitDistance = -1.0;
			}
		}
	}
	else if (SignalBufferLayout == 11)
	{
		 [unroll( 1 )]
		for (uint MultiplexId = 0; MultiplexId < 1; MultiplexId++)
		{
			float4 Channels = RawSample[MultiplexId].xyzw;
			float SampleCount = bNormalizeSample ? (Channels.g > 0 ? 1 : 0) : (Channels.g);
			OutSamples.Array[MultiplexId].MissCount = Channels.r * SampleCount;
			OutSamples.Array[MultiplexId].SampleCount = SampleCount;
			OutSamples.Array[MultiplexId].TransmissionDistance = Channels.a * SampleCount;
			OutSampleFrequencies.Array[MultiplexId].WorldBluringRadius = Channels.b;
		}
	}
	else if (SignalBufferLayout == 0x1002)
	{
		{
			const uint MultiplexId = 0;
			float Weight = RawSample[0].a;
			if (bNormalizeSample)
			{
				Weight = Weight > 0 ? 1 : 0;
			}
			OutSamples.Array[MultiplexId].SampleCount = Weight;
			OutSamples.Array[MultiplexId].SceneColor.rgb = RawSample[0].rgb * Weight;
		}
	}
	else if (SignalBufferLayout == 3)
	{
		OutSamples.Array[0].SampleCount = RawSample[1].r == -1.0 ? 0 : 1;
		OutSamples.Array[0].MissCount = RawSample[1].r == -1.0 ? 0 : (1 - RawSample[0].a);
		OutSamples.Array[0].SceneColor = RawSample[0];
		OutSampleFrequencies.Array[0].ConfusionFactor = RawSample[1].r;
	}
	else if (SignalBufferLayout == 4)
	{
		if (bNormalizeSample)
		{
			OutSamples.Array[0].SampleCount = RawSample[1].r > 0 ? 1 : 0;
		}
		else
		{
			OutSamples.Array[0].SampleCount = RawSample[1].r;
		}
		OutSamples.Array[0].MissCount = OutSamples.Array[0].SampleCount * (1 - RawSample[0].a);
		OutSamples.Array[0].SceneColor = OutSamples.Array[0].SampleCount * RawSample[0];
		OutSampleFrequencies.Array[0].ConfusionFactor = RawSample[1].g;
	}
	else if (SignalBufferLayout == 0xA000)
	{
		OutSamples.Array[0].SampleCount = RawSample[1].r < 0 ? 0 : 1;
		OutSamples.Array[0].MissCount = OutSamples.Array[0].SampleCount * RawSample[0].r;
		OutSampleFrequencies.Array[0].WorldBluringRadius = RawSample[1].r;
	}
	else if (SignalBufferLayout == 0xA001)
	{
		if (bNormalizeSample)
		{
			OutSamples.Array[0].SampleCount = RawSample[0].g > 0 ? 1 : 0;
			OutSamples.Array[0].MissCount = RawSample[0].g > 0 ? RawSample[0].r : 0;
		}
		else
		{
			OutSamples.Array[0].SampleCount = RawSample[0].g;
			OutSamples.Array[0].MissCount = RawSample[0].g * RawSample[0].r;
		}
	}
	else if (SignalBufferLayout == 0xA002)
	{
		if (bNormalizeSample)
		{
			OutSamples.Array[0].SampleCount = RawSample[0].g > 0 ? 1 : 0;
			OutSamples.Array[0].MissCount = RawSample[0].g > 0 ? RawSample[0].r : 0;
		}
		else
		{
			OutSamples.Array[0].SampleCount = RawSample[0].g;
			OutSamples.Array[0].MissCount = RawSample[0].g * RawSample[0].r;
		}
		OutSampleFrequencies.Array[0].WorldBluringRadius = RawSample[0].b;
	}
	else if (SignalBufferLayout == 0xD100)
	{
		OutSamples.Array[0].SampleCount = RawSample[1].g;
		OutSamples.Array[0].MissCount = OutSamples.Array[0].SampleCount * (1 - RawSample[0].a);
		OutSamples.Array[0].SceneColor = OutSamples.Array[0].SampleCount * RawSample[0];
		OutSampleFrequencies.Array[0].ClosestHitDistance = ((RawSample[1].r == -1.0) ? 1.0e20 : RawSample[1].r);
	}
	else if (SignalBufferLayout == 0xD101)
	{
		if (bNormalizeSample)
		{
			OutSamples.Array[0].SampleCount = RawSample[1].r > 0 ? 1 : 0;
		}
		else
		{
			OutSamples.Array[0].SampleCount = RawSample[1].r;
		}
		OutSamples.Array[0].MissCount = OutSamples.Array[0].SampleCount * (1 - RawSample[0].a);
		OutSamples.Array[0].SceneColor = OutSamples.Array[0].SampleCount * RawSample[0];
	}
	else if (SignalBufferLayout == 0xD102)
	{
		if (bNormalizeSample)
		{
			OutSamples.Array[0].SampleCount = RawSample[1].r > 0 ? 1 : 0;
		}
		else
		{
			OutSamples.Array[0].SampleCount = RawSample[1].r;
		}
		OutSamples.Array[0].MissCount = OutSamples.Array[0].SampleCount * (1 - RawSample[0].a);
		OutSamples.Array[0].SceneColor = OutSamples.Array[0].SampleCount * RawSample[0];
	}
	else if (SignalBufferLayout == 0xD300)
	{
		OutSamples.Array[0].SampleCount = RawSample[0].a;
		OutSamples.Array[0].MissCount = OutSamples.Array[0].SampleCount * RawSample[1].r;
		OutSamples.Array[0].SceneColor.rgb = OutSamples.Array[0].SampleCount * RawSample[0].rgb;
	}
	else if (SignalBufferLayout == 0xD301)
	{
		if (bNormalizeSample)
		{
			OutSamples.Array[0].SampleCount = RawSample[1].g > 0.0 ? 1.0 : 0.0;
		}
		else
		{
			OutSamples.Array[0].SampleCount = RawSample[1].g * 64.0;
		}
		OutSamples.Array[0].MissCount = OutSamples.Array[0].SampleCount * RawSample[1].r;
		OutSamples.Array[0].SceneColor.rgb = OutSamples.Array[0].SampleCount * RawSample[0].rgb;
	}
}
void DecodeMultiplexedSignals(
	const uint SignalBufferLayout,
	const uint MultiplexedSampleId,
	const bool bNormalizeSample,
	FSSDCompressedMultiplexedSample CompressedSample,
	out FSSDSignalArray OutSamples,
	out FSSDSignalFrequencyArray OutSampleFrequencies)
{
	DecodeMultiplexedSignalsFromFloat4(
		SignalBufferLayout,
		MultiplexedSampleId,
		bNormalizeSample,
		CompressedSample.VGPRArray,
		 OutSamples,
		 OutSampleFrequencies);
}
void EncodeMultiplexedSignals(
	const uint SignalBufferLayout, const uint MultiplexCount,
	FSSDSignalSample Sample[1],
	FSSDSignalFrequency SampleFrequency[1],
	out float4 OutRawSample[4],
	out uint OutBufferCount)
{
	 [unroll( 4 )]
	for (uint i = 0; i < 4; i++)
		OutRawSample[i] = 0;
	OutBufferCount = 1;
	if (0)
	{
	}
	else if (SignalBufferLayout == 11)
	{
		[unroll]
		for (uint MultiplexId = 0; MultiplexId < MultiplexCount; MultiplexId++)
		{
			float NormalizationFactor = SafeRcp(Sample[MultiplexId].SampleCount);
			float NormalizedTransmissionDistance = Sample[MultiplexId].TransmissionDistance * NormalizationFactor;
			OutRawSample[MultiplexId] = float4(
				Sample[MultiplexId].MissCount * NormalizationFactor,
				Sample[MultiplexId].SampleCount,
				SampleFrequency[MultiplexId].WorldBluringRadius,
				NormalizedTransmissionDistance);
		}
		OutBufferCount = MultiplexCount;
	}
	else if (SignalBufferLayout == 0x1002)
	{
		{
			const uint MultiplexId = 0;
			float NormalizationFactor = SafeRcp(Sample[MultiplexId].SampleCount);
			OutRawSample[0].rgb = ClampColorForEncoding(Sample[MultiplexId].SceneColor.rgb * NormalizationFactor);
			OutRawSample[0].a = Sample[MultiplexId].SampleCount;
		}
		OutBufferCount = 2;
	}
	else if (SignalBufferLayout == 4)
	{
		float NormalizationFactor = SafeRcp(Sample[0].SampleCount);
		OutRawSample[0] = ClampColorForEncoding(Sample[0].SceneColor * NormalizationFactor);
		OutRawSample[1].r = Sample[0].SampleCount;
		OutRawSample[1].g = SampleFrequency[0].ConfusionFactor;
		OutBufferCount = 2;
	}
	else if (SignalBufferLayout == 0xA001)
	{
		OutRawSample[0].r = Sample[0].SampleCount > 0 ? Sample[0].MissCount / Sample[0].SampleCount : 1.0;
		OutRawSample[0].g = Sample[0].SampleCount;
	}
	else if (SignalBufferLayout == 0xA002)
	{
		OutRawSample[0].r = Sample[0].SampleCount > 0 ? Sample[0].MissCount / Sample[0].SampleCount : 1.0;
		OutRawSample[0].g = Sample[0].SampleCount;
		OutRawSample[0].b = SampleFrequency[0].WorldBluringRadius;
	}
	else if (SignalBufferLayout == 0xD101)
	{
		float NormalizationFactor = SafeRcp(Sample[0].SampleCount);
		OutRawSample[0] = ClampColorForEncoding(Sample[0].SceneColor * NormalizationFactor);
		OutRawSample[1].r = Sample[0].SampleCount;
		OutBufferCount = 2;
	}
	else if (SignalBufferLayout == 0xD102)
	{
		float NormalizationFactor = SafeRcp(Sample[0].SampleCount);
		OutRawSample[0] = ClampColorForEncoding(Sample[0].SceneColor * NormalizationFactor);
		OutRawSample[1].r = Sample[0].SampleCount;
		OutBufferCount = 2;
	}
	else if (SignalBufferLayout == 0xD301)
	{
		float NormalizationFactor = SafeRcp(Sample[0].SampleCount);
		OutRawSample[0].rgb = ClampColorForEncoding(Sample[0].SceneColor * NormalizationFactor).rgb;
		OutRawSample[1].g = saturate(Sample[0].SampleCount * rcp(64.0));
		OutRawSample[1].r = Sample[0].MissCount * NormalizationFactor;
		OutBufferCount = 2;
	}
}
FSSDCompressedMultiplexedSample SampleCompressedMultiplexedSignals(
	Texture2D SignalBuffer0, Texture2D SignalBuffer1, Texture2D SignalBuffer2, Texture2D SignalBuffer3,
	SamplerState Sampler, float2 UV, uint2 PixelCoord)
{
	FSSDCompressedMultiplexedSample CompressedSample;
	 
	{
		{
			CompressedSample.VGPRArray[0] = SignalBuffer0.SampleLevel(Sampler, UV, 0.0);
			CompressedSample.VGPRArray[1] = SignalBuffer1.SampleLevel(Sampler, UV, 0.0);
			CompressedSample.VGPRArray[2] = SignalBuffer2.SampleLevel(Sampler, UV, 0.0);
			CompressedSample.VGPRArray[3] = SignalBuffer3.SampleLevel(Sampler, UV, 0.0);
		}
	}
	return CompressedSample;
}
void SampleMultiplexedSignals( 
	Texture2D SignalBuffer0, Texture2D SignalBuffer1, Texture2D SignalBuffer2, Texture2D SignalBuffer3,
	SamplerState Sampler,
	const uint SignalBufferLayout, const uint MultiplexedSampleId,
	const bool bNormalizeSample,
	float2 UV,
	out FSSDSignalArray OutMultiplexedSamples,
	out FSSDSignalFrequencyArray OutMultiplexedFrequencies)
{
	uint2 PixelCoord = BufferUVToBufferPixelCoord(UV);
	FSSDCompressedMultiplexedSample CompressedSample = SampleCompressedMultiplexedSignals(
		SignalBuffer0, SignalBuffer1, SignalBuffer2, SignalBuffer3,
		Sampler, UV, PixelCoord);
	DecodeMultiplexedSignals(
		SignalBufferLayout, MultiplexedSampleId, bNormalizeSample, CompressedSample,
		 OutMultiplexedSamples,
		 OutMultiplexedFrequencies);
}
void OutputMultiplexedSignal(
	RWTexture2D<float4>  OutputSignalBuffer0,
	RWTexture2D<float4>  OutputSignalBuffer1,
	RWTexture2D<float4>  OutputSignalBuffer2,
	RWTexture2D<float4>  OutputSignalBuffer3,
	const uint SignalBufferLayout, const uint MultiplexCount,
	const uint2 PixelPosition,
	FSSDSignalArray MultiplexedSamples,
	FSSDSignalFrequencyArray MultiplexedFrequencies)
{
	float4 RawSample[4];
	uint BufferCount;
	EncodeMultiplexedSignals(
		SignalBufferLayout, MultiplexCount,
		MultiplexedSamples.Array,
		MultiplexedFrequencies.Array,
		 RawSample,  BufferCount);
	if (BufferCount >= 1)
		OutputSignalBuffer0[PixelPosition] = RawSample[0];
	if (BufferCount >= 2)
		OutputSignalBuffer1[PixelPosition] = RawSample[1];
	if (BufferCount >= 3)
		OutputSignalBuffer2[PixelPosition] = RawSample[2];
	if (BufferCount >= 4)
		OutputSignalBuffer3[PixelPosition] = RawSample[3];
}
static const uint2 BilinearSamplingOffsets2x2[4] =
{
	int2(0,  0),
	int2(1,  0),
	int2(0,  1),
	int2(1,  1),
};
struct FBilinearSampleInfos
{
	float2 TextureInvSize;
	float2 TopLeftPixelCoord;
	float2 BilinearInterp;
};
FBilinearSampleInfos GetBilinearSampleLevelInfosEx(float2 SampleUV, float2 TextureSize, float2 TextureInvSize, float MipLevelPow2, float InvMipLevelPow2)
{
	FBilinearSampleInfos Infos;
	float2 HistoryBufferPixelCoord = SampleUV * TextureSize * InvMipLevelPow2;
	Infos.TextureInvSize = TextureInvSize * MipLevelPow2;
	Infos.TopLeftPixelCoord = floor(HistoryBufferPixelCoord - 0.5);
	Infos.BilinearInterp = frac(HistoryBufferPixelCoord - 0.5);
	return Infos;
}
float GetSampleWeight(FBilinearSampleInfos SampleInfos, const uint SampleId)
{
	float BilinearSampleWeights[4] = {
		(1 - SampleInfos.BilinearInterp.x) * (1 - SampleInfos.BilinearInterp.y),
		(SampleInfos.BilinearInterp.x) * (1 - SampleInfos.BilinearInterp.y),
		(1 - SampleInfos.BilinearInterp.x) * (SampleInfos.BilinearInterp.y),
		(SampleInfos.BilinearInterp.x) * (SampleInfos.BilinearInterp.y),
	};
	return BilinearSampleWeights[SampleId];
}
struct FSSDKernelConfig
{
	uint SampleSet;
	uint SampleSubSetId;
	uint BufferLayout;
	uint MultiplexedSignalsPerSignalDomain;
	uint BilateralDistanceComputation;
	uint RingCount;
	uint NeighborToRefComputation;
	uint RefSceneMetadataLayout;
	float WorldBluringDistanceMultiplier;
	bool bUnroll;
	bool bSampleKernelCenter;
	bool bPreviousFrameMetadata;
	bool bPreviousFrameRefMetadata;
	bool bDescOrder;
	bool bNormalizeSample;
	bool bMinSamplePairInvFrequency;
	bool bMaxWithRefBilateralDistance;
	bool bComputeSampleColorSH;
	bool bClampUVPerMultiplexedSignal;
	uint BufferColorSpace[1];
	uint AccumulatorColorSpace[1];
	uint BilateralSettings[1];
	float4 BufferSizeAndInvSize;
	float4 BufferBilinearUVMinMax;
	float KernelSpreadFactor;
	float HarmonicPeriode;
	float4 PerSignalUVMinMax[1];
	uint BoxKernelRadius;
	uint SampleCount;
	float2 BufferUV;
	FSSDCompressedSceneInfos CompressedRefSceneMetadata;
	float2 RefBufferUV;
	bool bForceKernelCenterAccumulation;
	bool bForceAllAccumulation;
	bool bIsDynamicPixel;
	uint SampleTrackId;
	float RefBilateralDistance[1];
	float Randoms[1];
	uint2 HammersleySeed;
	float2 MajorAxis;
	float MajorPixelRadius;
	float MinorPixelRadius;
};
FSSDKernelConfig CreateKernelConfig()
{
	FSSDKernelConfig KernelConfig;
	KernelConfig.SampleSet = 0;
	KernelConfig.SampleSubSetId = 0;
	KernelConfig.BufferLayout = 0xDEAD;
	KernelConfig.MultiplexedSignalsPerSignalDomain = 1;
	KernelConfig.NeighborToRefComputation = 0;
	KernelConfig.RefSceneMetadataLayout = 0;
	KernelConfig.RingCount = 0;
	KernelConfig.WorldBluringDistanceMultiplier = 1.0;
	KernelConfig.bUnroll = false;
	KernelConfig.bSampleKernelCenter = false;
	KernelConfig.bPreviousFrameMetadata = false;
	KernelConfig.bPreviousFrameRefMetadata = false;
	KernelConfig.BilateralDistanceComputation = 2;
	KernelConfig.bDescOrder = false;
	KernelConfig.bNormalizeSample = false;
	KernelConfig.bMinSamplePairInvFrequency = false;
	KernelConfig.bMaxWithRefBilateralDistance = false;
	KernelConfig.bComputeSampleColorSH = false;
	KernelConfig.bClampUVPerMultiplexedSignal = false;
	{
		 [unroll( 1 )]
		for (uint MultiplexId = 0; MultiplexId < 1; MultiplexId++)
		{
			KernelConfig.BufferColorSpace[MultiplexId] = 0x0;
			KernelConfig.AccumulatorColorSpace[MultiplexId] = 0x0;
			KernelConfig.BilateralSettings[MultiplexId] = 0x0000;
		}
	}
	KernelConfig.BufferSizeAndInvSize = float4(0, 0, 0, 0);
	KernelConfig.BufferBilinearUVMinMax = float4(0, 0, 0, 0);
	KernelConfig.KernelSpreadFactor = 1;
	KernelConfig.HarmonicPeriode = 1.0;
	{
		 [unroll( 1 )]
		for (uint MultiplexId = 0; MultiplexId < 1; MultiplexId++)
		{
			KernelConfig.PerSignalUVMinMax[MultiplexId] = 0.0;
		}
	}
	KernelConfig.BoxKernelRadius = 1;
	KernelConfig.SampleCount = 1;
	KernelConfig.BufferUV = 0.0;
	KernelConfig.CompressedRefSceneMetadata = CreateCompressedSceneInfos();
	KernelConfig.RefBufferUV = 0.0;
	KernelConfig.bForceKernelCenterAccumulation = false;
	KernelConfig.bForceAllAccumulation = false;
	KernelConfig.bIsDynamicPixel = false;
	KernelConfig.SampleTrackId = 0;
	KernelConfig.MajorAxis = 0.0;
	KernelConfig.MajorPixelRadius = 0.0;
	KernelConfig.MinorPixelRadius = 0.0;
	KernelConfig.HammersleySeed = 0;
	{	
		 [unroll( 1 )]
		for (uint MultiplexId = 0; MultiplexId < 1; MultiplexId++)
		{
			KernelConfig.RefBilateralDistance[MultiplexId] = 0.0;
		}
	}
	{	
		 [unroll( 2 )]
		for (uint RandomSignalId = 0; RandomSignalId < 1; RandomSignalId++)
		{
			KernelConfig.Randoms[RandomSignalId] = 0.0;
		}
	}
	return KernelConfig;
}
void SetBilateralPreset(uint BilateralPresetId, inout FSSDKernelConfig KernelConfig)
{
	if (BilateralPresetId == 0x0011)
	{
		 [unroll( 1 )]
		for (uint MultiplexId = 0; MultiplexId < 1; MultiplexId++)
		{
			KernelConfig.BilateralSettings[MultiplexId] =  (0x0000 + ( 5 ) & 0xF) | 0x0010;
		}
	}
	else if (BilateralPresetId == 0x0022)
	{
		KernelConfig.BilateralSettings[0] =  (0x0000 + ( 5 ) & 0xF) | 0x0010;
	}
	else if (BilateralPresetId == 0x1001)
	{
		KernelConfig.BilateralSettings[0] = (0x0020 | 0x0040);
	}
	else if (BilateralPresetId == 0x1002)
	{
		KernelConfig.BilateralSettings[0] = 0x0020;
	}
	else if (BilateralPresetId == 0x1003)
	{
		KernelConfig.BilateralSettings[0] =  (0x0000 + ( 1 ) & 0xF) | (0x0020 | 0x0040);
	}
	else if (BilateralPresetId == 0x2001)
	{
		KernelConfig.BilateralSettings[0] =  (0x0000 + ( 2 ) & 0xF) | 0x0010;
	}
	else if (BilateralPresetId == 0x3001)
	{
		KernelConfig.BilateralSettings[0] =  (0x0000 + ( 2 ) & 0xF);
	}
	else if (BilateralPresetId == 0xF000)
	{
		KernelConfig.BilateralSettings[0] =  (0x0000 + ( 1 ) & 0xF) | 0x0080;
	}
	else if (BilateralPresetId == 0x4001)
	{
		KernelConfig.BilateralSettings[0] =  (0x0000 + ( 4 ) & 0xF) | 0x0010;
	}
	else if (BilateralPresetId == 0x4002)
	{
		KernelConfig.BilateralSettings[0] =  (0x0000 + ( 2 ) & 0xF) | 0x0010;
	}
}
static const float kWaveletFilterWeights5x5[] = { 3.0 / 8.0, 1.0 / 4.0, 1.0 / 16.0 };
float2 ComputeRefBufferUV(FSSDKernelConfig KernelConfig)
{
	if (KernelConfig.bPreviousFrameMetadata)
	{
		return KernelConfig.RefBufferUV;
	}
	else if (KernelConfig.SampleSet == 11)
	{
		return KernelConfig.RefBufferUV;
	}
	else if (KernelConfig.SampleSet == 8)
	{
		uint SampleTrackId = KernelConfig.SampleTrackId;
		float2 SampleOffset = float2(
			SampleTrackId & 0x1 ? 0.5 : -0.5,
			SampleTrackId & 0x2 ? 0.5 : -0.5);
		return KernelConfig.BufferUV + SampleOffset * KernelConfig.BufferSizeAndInvSize.zw;
	}
	return KernelConfig.BufferUV;
}
FSSDSampleSceneInfos UncompressRefSceneMetadata(FSSDKernelConfig KernelConfig)
{
	float2 RefBufferUV = ComputeRefBufferUV(KernelConfig);
	float2 ScreenPos;
	if (KernelConfig.bPreviousFrameMetadata) 
	{
		ScreenPos = RefBufferUV * PrevSceneBufferUVToScreenPosition.xy + PrevSceneBufferUVToScreenPosition.zw;
	}
	else
	{
		ScreenPos = DenoiserBufferUVToScreenPosition(RefBufferUV);
	}
	return UncompressSampleSceneInfo(
		KernelConfig.RefSceneMetadataLayout, KernelConfig.bPreviousFrameRefMetadata,
		ScreenPos,
		KernelConfig.CompressedRefSceneMetadata);
}
FSSDSampleSceneInfos UncompressSampleSceneMetadata(
	FSSDKernelConfig KernelConfig,
	float2 SampleBufferUV,
	FSSDCompressedSceneInfos CompressedSampleSceneMetadata)
{
	float2 ScreenPos;
	if (KernelConfig.bPreviousFrameMetadata)
	{
		ScreenPos = SampleBufferUV * PrevSceneBufferUVToScreenPosition.xy + PrevSceneBufferUVToScreenPosition.zw;
	}
	else
	{
		ScreenPos = DenoiserBufferUVToScreenPosition(SampleBufferUV);
	}
	return UncompressSampleSceneInfo(
		0, KernelConfig.bPreviousFrameMetadata,
		ScreenPos,
		CompressedSampleSceneMetadata);
}
float3 ComputeVectorFromNeighborToRef(
	FSSDKernelConfig KernelConfig,
	FSSDSampleSceneInfos RefSceneMetadata,
	FSSDSampleSceneInfos NeighborSceneMetadata)
{
	float RefWorldDepth = GetWorldDepth(RefSceneMetadata);
	float NeighborWorldDepth = GetWorldDepth(NeighborSceneMetadata);
	if (KernelConfig.NeighborToRefComputation == 1)
	{
		float2 RefScreenPos = RefSceneMetadata.ScreenPosition;
		float3 RefClipPosition = float3(GetScreenPositionForProjectionType(RefScreenPos, RefWorldDepth), RefWorldDepth);
		float2 NeighborScreenPos = NeighborSceneMetadata.ScreenPosition;
		float3 NeighborClipPosition = float3(GetScreenPositionForProjectionType(NeighborScreenPos, NeighborWorldDepth), NeighborWorldDepth);
			float3 NeighborToRefVector = mul(float4(RefClipPosition - NeighborClipPosition, 0), View.ScreenToTranslatedWorld).xyz;
		return NeighborToRefVector;
	}
	else 
	{
		float3 NeighborToRefWorldVector = GetTranslatedWorldPosition(RefSceneMetadata) - GetTranslatedWorldPosition(NeighborSceneMetadata);
		return NeighborToRefWorldVector;
	}
}
FSSDSignalSample TransformSignalSampleForAccumulation(
	FSSDKernelConfig KernelConfig,
	uint MultiplexId,
	FSSDSampleSceneInfos SampleSceneMetadata,
	FSSDSignalSample Sample,
	uint2 SamplePixelCoord)
{
	Sample = TransformSignal(
		Sample, 
		 KernelConfig.BufferColorSpace[MultiplexId], 
		 KernelConfig.AccumulatorColorSpace[MultiplexId]);
	return Sample;
}
uint ComputeSignalBatchIdFromSignalMultiplexId(FSSDKernelConfig KernelConfig, const uint SignalMultiplexId)
{
	return SignalMultiplexId / KernelConfig.MultiplexedSignalsPerSignalDomain;
}
bool IsOutsideViewport(FSSDKernelConfig KernelConfig, float2 SampleBufferUV)
{
	return any( or_internal( SampleBufferUV < KernelConfig.BufferBilinearUVMinMax.xy , SampleBufferUV > KernelConfig.BufferBilinearUVMinMax.zw ));
}
void SampleMultiplexedSignals(
	FSSDKernelConfig KernelConfig,
	Texture2D SignalBuffer0,
	Texture2D SignalBuffer1,
	Texture2D SignalBuffer2,
	Texture2D SignalBuffer3,
	float2 SampleBufferUV,
	out FSSDCompressedSceneInfos OutCompressedSampleSceneMetadata,
	out FSSDCompressedMultiplexedSample OutCompressedMultiplexedSamples)
{
	uint2 PixelCoord = BufferUVToBufferPixelCoord(SampleBufferUV);
	OutCompressedSampleSceneMetadata = SampleCompressedSceneMetadata(
		KernelConfig.bPreviousFrameMetadata, SampleBufferUV, PixelCoord);
	OutCompressedMultiplexedSamples = SampleCompressedMultiplexedSignals(
		SignalBuffer0,
		SignalBuffer1,
		SignalBuffer2,
		SignalBuffer3,
		 D3DStaticPointClampedSampler,
		SampleBufferUV,
		PixelCoord);
}
void UncompressMultiplexedSignals(
	FSSDKernelConfig KernelConfig,
	float2 SampleBufferUV,
	FSSDCompressedMultiplexedSample CompressedMultiplexedSamples,
	out FSSDSignalArray MultiplexedSamples,
	out FSSDSignalFrequencyArray MultiplexedFrequencies)
{
	DecodeMultiplexedSignals(
		KernelConfig.BufferLayout,
		 0,
		KernelConfig.bNormalizeSample,
		CompressedMultiplexedSamples,
		 MultiplexedSamples,
		 MultiplexedFrequencies);
	if (KernelConfig.bClampUVPerMultiplexedSignal)
	{
		 [unroll( 1 )]
		for (uint SignalMultiplexId = 0; SignalMultiplexId < 1; SignalMultiplexId++)
		{
			bool bInvalidSample = any(SampleBufferUV != clamp(
				SampleBufferUV, KernelConfig.PerSignalUVMinMax[SignalMultiplexId].xy, KernelConfig.PerSignalUVMinMax[SignalMultiplexId].zw));
			if (bInvalidSample)
			{
				MultiplexedSamples.Array[SignalMultiplexId] = CreateSignalSampleFromScalarValue(0.0);
			}
		} 
	}
}
void AccumulateSampledMultiplexedSignals(
	FSSDKernelConfig KernelConfig,
	inout FSSDSignalAccumulatorArray UncompressedAccumulators,
	inout FSSDCompressedSignalAccumulatorArray CompressedAccumulators,
	FSSDSampleSceneInfos RefSceneMetadata,
	float2 SampleBufferUV,
	FSSDSampleSceneInfos SampleSceneMetadata,
	FSSDSignalArray MultiplexedSamples,
	FSSDSignalFrequencyArray MultiplexedFrequencies,
	float KernelSampleWeight,
	const bool bForceSample,
	bool bIsOutsideFrustum)
{
	float RefPixelWorldBluringRadius = ComputeWorldBluringRadiusCausedByPixelSize(RefSceneMetadata);
	float3 NeighborToRefVector = ComputeVectorFromNeighborToRef(
		KernelConfig,
		RefSceneMetadata,
		SampleSceneMetadata);
	 [unroll( 1 )]
	for (uint SignalMultiplexId = 0; SignalMultiplexId < 1; SignalMultiplexId++)
	{
		const uint BatchedSignalId = ComputeSignalBatchIdFromSignalMultiplexId(KernelConfig, SignalMultiplexId);
		FSSDSignalDomainKnowledge DomainKnowledge = GetSignalDomainKnowledge(BatchedSignalId);
		uint2 NeighborPixelCoord = floor(SampleBufferUV * KernelConfig.BufferSizeAndInvSize.xy);
		FSSDSignalSample Sample = MultiplexedSamples.Array[SignalMultiplexId];
		Sample = TransformSignalSampleForAccumulation(KernelConfig, SignalMultiplexId, SampleSceneMetadata, Sample, NeighborPixelCoord);
		FSSDSignalFrequency SampleFrequency = MultiplexedFrequencies.Array[SignalMultiplexId];
		float SamplePixelWorldBluringRadius = ComputeWorldBluringRadiusCausedByPixelSize(SampleSceneMetadata);
		float SignalConvolutionBluringRadius = GetSignalWorldBluringRadius(SampleFrequency, SampleSceneMetadata, DomainKnowledge);
		if (KernelConfig.BilateralDistanceComputation == 4)
		{
			SignalConvolutionBluringRadius = SampleFrequency.WorldBluringRadius;
		}
		float FinalWorldBluringDistance = -1;
		if (KernelConfig.BilateralDistanceComputation == 0)
		{
			FinalWorldBluringDistance = AmendWorldBluringRadiusCausedByPixelSize(
				RefPixelWorldBluringRadius);
		}
		else if (KernelConfig.BilateralDistanceComputation == 1)
		{
			FinalWorldBluringDistance = AmendWorldBluringRadiusCausedByPixelSize(
				SamplePixelWorldBluringRadius);
		}
		else if (KernelConfig.BilateralDistanceComputation == 2)
		{
			FinalWorldBluringDistance = AmendWorldBluringRadiusCausedByPixelSize(
				min(SamplePixelWorldBluringRadius, RefPixelWorldBluringRadius));
		}
		else if (
			KernelConfig.BilateralDistanceComputation == 3 ||
			KernelConfig.BilateralDistanceComputation == 4)
		{
			FinalWorldBluringDistance = SignalConvolutionBluringRadius;
		}
		else if (KernelConfig.BilateralDistanceComputation == 5)
		{
			FinalWorldBluringDistance = AmendWorldBluringRadiusCausedByPixelSize(
				RefPixelWorldBluringRadius) * KernelConfig.HarmonicPeriode;
		}
		FinalWorldBluringDistance *= KernelConfig.WorldBluringDistanceMultiplier;
		if (KernelConfig.bMaxWithRefBilateralDistance)
		{
			FinalWorldBluringDistance = min(FinalWorldBluringDistance, KernelConfig.RefBilateralDistance[SignalMultiplexId]);
		}
		float BilateralWeight = ComputeBilateralWeight(
			KernelConfig.BilateralSettings[SignalMultiplexId],
			FinalWorldBluringDistance,
			DomainKnowledge,
			RefSceneMetadata,
			SampleSceneMetadata,
			NeighborToRefVector);
		FSSDSampleAccumulationInfos SampleInfos;
		SampleInfos.Sample = Sample;
		SampleInfos.Frequency = SampleFrequency;
		SampleInfos.FinalWeight = KernelSampleWeight * BilateralWeight;
		SampleInfos.InvFrequency = SignalConvolutionBluringRadius;
		if (bForceSample || KernelConfig.bForceAllAccumulation)
		{
			SampleInfos.FinalWeight = 1;
		}
		[flatten]
		if (SampleInfos.Sample.SampleCount != 0 && !bIsOutsideFrustum)
		{
			{
				AccumulateSample(
					 UncompressedAccumulators.Array[SignalMultiplexId],
					SampleInfos);
			}
		}
	} 
}
void SampleAndAccumulateMultiplexedSignals(
	FSSDKernelConfig KernelConfig,
	Texture2D SignalBuffer0,
	Texture2D SignalBuffer1,
	Texture2D SignalBuffer2,
	Texture2D SignalBuffer3,
	inout FSSDSignalAccumulatorArray UncompressedAccumulators,
	inout FSSDCompressedSignalAccumulatorArray CompressedAccumulators,
	float2 SampleBufferUV,
	float KernelSampleWeight,
	const bool bForceSample)
{
	bool bIsOutsideFrustum = IsOutsideViewport(KernelConfig, SampleBufferUV);
	FSSDCompressedSceneInfos CompressedSampleSceneMetadata;
	FSSDCompressedMultiplexedSample CompressedMultiplexedSamples;
	 
	{
		SampleMultiplexedSignals(
			KernelConfig,
			SignalBuffer0,
			SignalBuffer1,
			SignalBuffer2,
			SignalBuffer3,
			SampleBufferUV,
			 CompressedSampleSceneMetadata,
			 CompressedMultiplexedSamples);
	}
	{
		FSSDSignalArray MultiplexedSamples;
		FSSDSignalFrequencyArray MultiplexedFrequencies;
		UncompressMultiplexedSignals(
			KernelConfig, SampleBufferUV, CompressedMultiplexedSamples,
			 MultiplexedSamples,
			 MultiplexedFrequencies);
		FSSDSampleSceneInfos RefSceneMetadata = UncompressRefSceneMetadata(KernelConfig);
		FSSDSampleSceneInfos SampleSceneMetadata = UncompressSampleSceneMetadata(
			KernelConfig, SampleBufferUV, CompressedSampleSceneMetadata);
		AccumulateSampledMultiplexedSignals(
			KernelConfig,
			 UncompressedAccumulators,
			 CompressedAccumulators,
			RefSceneMetadata,
			SampleBufferUV,
			SampleSceneMetadata,
			MultiplexedSamples,
			MultiplexedFrequencies,
			KernelSampleWeight,
			bForceSample,
			bIsOutsideFrustum);
	}
}
void SampleAndAccumulateMultiplexedSignalsPair(
	FSSDKernelConfig KernelConfig,
	Texture2D SignalBuffer0,
	Texture2D SignalBuffer1,
	Texture2D SignalBuffer2,
	Texture2D SignalBuffer3,
	inout FSSDSignalAccumulatorArray UncompressedAccumulators,
	inout FSSDCompressedSignalAccumulatorArray CompressedAccumulators,
	float2 SampleBufferUV[2],
	float KernelSampleWeight)
{
	FSSDCompressedSceneInfos CompressedSampleSceneMetadata[2];
	FSSDCompressedMultiplexedSample CompressedMultiplexedSamples[2];
	bool bIsOutsideFrustum[2];
	 
	{
		 [unroll( 2 )]
		for (uint PairFetchId = 0; PairFetchId < 2; PairFetchId++)
		{
			bIsOutsideFrustum[PairFetchId] = IsOutsideViewport(KernelConfig, SampleBufferUV[PairFetchId]);
			SampleMultiplexedSignals(
				KernelConfig,
				SignalBuffer0,
				SignalBuffer1,
				SignalBuffer2,
				SignalBuffer3,
				SampleBufferUV[PairFetchId],
				 CompressedSampleSceneMetadata[PairFetchId],
				 CompressedMultiplexedSamples[PairFetchId]);
		}
	}
	{
		FSSDSignalArray MultiplexedSamples[2];
		FSSDSignalFrequencyArray MultiplexedFrequencies[2];
		 [unroll( 2 )]
		for (uint PairUncompressId = 0; PairUncompressId < 2; PairUncompressId++)
		{
			UncompressMultiplexedSignals(
				KernelConfig,
				SampleBufferUV[PairUncompressId],
				CompressedMultiplexedSamples[PairUncompressId],
				 MultiplexedSamples[PairUncompressId],
				 MultiplexedFrequencies[PairUncompressId]);
		}
		if (KernelConfig.bMinSamplePairInvFrequency)
		{
			 [unroll( 1 )]
			for (uint SignalMultiplexId = 0; SignalMultiplexId < 1; SignalMultiplexId++)
			{
				float MinInvFrequency = min(
					MultiplexedFrequencies[0].Array[SignalMultiplexId].WorldBluringRadius,
					MultiplexedFrequencies[1].Array[SignalMultiplexId].WorldBluringRadius);
				[flatten]
				if (MinInvFrequency > 0)
				{
					MultiplexedFrequencies[0].Array[SignalMultiplexId].WorldBluringRadius = MinInvFrequency;
					MultiplexedFrequencies[1].Array[SignalMultiplexId].WorldBluringRadius = MinInvFrequency;
				}
			}
		}
		FSSDSampleSceneInfos RefSceneMetadata = UncompressRefSceneMetadata(KernelConfig);
		 [unroll( 2 )]
		for (uint PairAccumulateId = 0; PairAccumulateId < 2; PairAccumulateId++)
		{
			FSSDSampleSceneInfos SampleSceneMetadata = UncompressSampleSceneMetadata(
				KernelConfig, SampleBufferUV[PairAccumulateId], CompressedSampleSceneMetadata[PairAccumulateId]);
			AccumulateSampledMultiplexedSignals(
				KernelConfig,
				 UncompressedAccumulators,
				 CompressedAccumulators,
				RefSceneMetadata,
				SampleBufferUV[PairAccumulateId],
				SampleSceneMetadata,
				MultiplexedSamples[PairAccumulateId],
				MultiplexedFrequencies[PairAccumulateId],
				KernelSampleWeight,
				 false,
				bIsOutsideFrustum[PairAccumulateId]);
		}
	}
}
void StartAccumulatingCluster(
	FSSDKernelConfig KernelConfig,
	inout FSSDSignalAccumulatorArray UncompressedAccumulators,
	inout FSSDCompressedSignalAccumulatorArray CompressedAccumulators,
	FSSDSampleClusterInfo ClusterInfo)
{
	FSSDSampleSceneInfos RefSceneMetadata = UncompressRefSceneMetadata(KernelConfig);
	 [unroll( 1 )]
	for (uint SignalMultiplexId = 0; SignalMultiplexId < 1; SignalMultiplexId++)
	{
		{
			StartAccumulatingCluster(
				RefSceneMetadata,
				 UncompressedAccumulators.Array[SignalMultiplexId],
				ClusterInfo);
		}
	}
}
void DijestAccumulatedClusterSamples(
	inout FSSDSignalAccumulatorArray UncompressedAccumulators,
	inout FSSDCompressedSignalAccumulatorArray CompressedAccumulators,
	uint RingId, uint SampleCount)
{
	 [unroll( 1 )]
	for (uint SignalMultiplexId = 0; SignalMultiplexId < 1; SignalMultiplexId++)
	{
		{
			DijestAccumulatedClusterSamples(
				 UncompressedAccumulators.Array[SignalMultiplexId],
				RingId, SampleCount);
		}
	}
}
void SampleAndAccumulateCenterSampleAsItsOwnCluster(
	FSSDKernelConfig KernelConfig,
	Texture2D SignalBuffer0,
	Texture2D SignalBuffer1,
	Texture2D SignalBuffer2,
	Texture2D SignalBuffer3,
	inout FSSDSignalAccumulatorArray UncompressedAccumulators,
	inout FSSDCompressedSignalAccumulatorArray CompressedAccumulators)
{
	const uint RingId = 0;
	FSSDSampleClusterInfo ClusterInfo;
	ClusterInfo.OutterBoundaryRadius = (RingId + 1) * KernelConfig.KernelSpreadFactor;
	StartAccumulatingCluster(
		KernelConfig, 
		 UncompressedAccumulators,
		 CompressedAccumulators,
		ClusterInfo);
	SampleAndAccumulateMultiplexedSignals(
		KernelConfig,
		SignalBuffer0,
		SignalBuffer1,
		SignalBuffer2,
		SignalBuffer3,
		 UncompressedAccumulators,
		 CompressedAccumulators,
		KernelConfig.BufferUV,
		 1.0,
		 KernelConfig.bForceKernelCenterAccumulation);
	DijestAccumulatedClusterSamples(
		 UncompressedAccumulators,
		 CompressedAccumulators,
		RingId,  1);
}
void AccumulateBilinear2x2Kernel(
	FSSDKernelConfig KernelConfig,
	Texture2D SignalBuffer0,
	Texture2D SignalBuffer1,
	Texture2D SignalBuffer2,
	Texture2D SignalBuffer3,
	inout FSSDSignalAccumulatorArray UncompressedAccumulators,
	inout FSSDCompressedSignalAccumulatorArray CompressedAccumulators)
{
	const float MipLevelPow2 = 1;
	FBilinearSampleInfos BilinearInfos = GetBilinearSampleLevelInfosEx(
		KernelConfig.BufferUV,
		KernelConfig.BufferSizeAndInvSize.xy,
		KernelConfig.BufferSizeAndInvSize.zw,
		MipLevelPow2, rcp(MipLevelPow2));
	bool bUseStocasticBilinear = false;
	if (KernelConfig.SampleSet == 13)
	{
		bUseStocasticBilinear = true;
	}
	else if (KernelConfig.SampleSet == 17)
	{
		bUseStocasticBilinear = !KernelConfig.bIsDynamicPixel;
	}
	float2 SampleBufferUVArray[4];
	float BilinearWeightArray[4];
	[flatten]
	if (bUseStocasticBilinear)
	{
		float2 SampleOffset = 0;
		float WeigthAccumulation = 0.0;
		 [unroll( 4 )]
		for (uint i = 0; i < 4; i++)
		{
			[flatten]
			if (KernelConfig.Randoms[0] > WeigthAccumulation)
				SampleOffset = BilinearSamplingOffsets2x2[i];
			WeigthAccumulation += GetSampleWeight(BilinearInfos, i);
			BilinearWeightArray[i] = 0.0;
			SampleBufferUVArray[i] = 0.0;
		}
		SampleBufferUVArray[0] = (BilinearInfos.TopLeftPixelCoord + (SampleOffset + 0.5)) * MipLevelPow2 * KernelConfig.BufferSizeAndInvSize.zw;
		BilinearWeightArray[0] = 1.0;
	}
	else
	{
		 [unroll( 4 )]
		for (uint i = 0; i < 4; i++)
		{
			float2 SampleOffset = BilinearSamplingOffsets2x2[i];
			SampleBufferUVArray[i] = (BilinearInfos.TopLeftPixelCoord + (SampleOffset + 0.5)) * MipLevelPow2 * KernelConfig.BufferSizeAndInvSize.zw;
			BilinearWeightArray[i] = GetSampleWeight(BilinearInfos, i);
		}
	}
	{
		SampleAndAccumulateMultiplexedSignals(
			KernelConfig,
			SignalBuffer0,
			SignalBuffer1,
			SignalBuffer2,
			SignalBuffer3,
			 UncompressedAccumulators,
			 CompressedAccumulators,
			SampleBufferUVArray[0],
			BilinearWeightArray[0],
			 false);
	}
	[branch]
	if (!bUseStocasticBilinear)
	{
		 [unroll( 3 )]
		for (uint i = 1; i < 4; i++)
		{
			SampleAndAccumulateMultiplexedSignals(
				KernelConfig,
				SignalBuffer0,
				SignalBuffer1,
				SignalBuffer2,
				SignalBuffer3,
				 UncompressedAccumulators,
				 CompressedAccumulators,
				SampleBufferUVArray[i],
				BilinearWeightArray[i],
				 false);
		}
	}
}
void AccumulateSquareKernel(
	FSSDKernelConfig KernelConfig,
	Texture2D SignalBuffer0,
	Texture2D SignalBuffer1,
	Texture2D SignalBuffer2,
	Texture2D SignalBuffer3,
	inout FSSDSignalAccumulatorArray UncompressedAccumulators,
	inout FSSDCompressedSignalAccumulatorArray CompressedAccumulators)
{
	int KernelRadius = 1;
	if (KernelConfig.SampleSet == 4)
	{
		KernelRadius = 2;
	}
	else if (KernelConfig.SampleSet == 7)
	{
		KernelRadius = KernelConfig.BoxKernelRadius;
	}
	if (KernelConfig.bUnroll)
	{
		[unroll] for (int x = -KernelRadius; x <= KernelRadius; x++)
		{
			[unroll] for (int y = -KernelRadius; y <= KernelRadius; y++)
			{
				const bool bIsKernelCenterSample = x == 0 && y == 0;
				if (bIsKernelCenterSample && !KernelConfig.bSampleKernelCenter) continue;
				float2 SampleOffset = float2(x, y);
				if (KernelConfig.SampleSet == 3)
				{
					SampleOffset = mul(float2x2(float2(2, -1), float2(1, 2)), SampleOffset);
				}
				float2 SampleBufferUV = KernelConfig.BufferUV + (SampleOffset * KernelConfig.KernelSpreadFactor) * KernelConfig.BufferSizeAndInvSize.zw;
				float KernelWeight = 1;
				if (KernelConfig.SampleSet == 4)
				{
					KernelWeight = 
						kWaveletFilterWeights5x5[abs(x)] *
						kWaveletFilterWeights5x5[abs(y)] *
						rcp(kWaveletFilterWeights5x5[0] * kWaveletFilterWeights5x5[0]);
				}
				SampleAndAccumulateMultiplexedSignals(
					KernelConfig,
					SignalBuffer0,
					SignalBuffer1,
					SignalBuffer2,
					SignalBuffer3,
					 UncompressedAccumulators,
					 CompressedAccumulators,
					SampleBufferUV,
					KernelWeight,
					 bIsKernelCenterSample && KernelConfig.bForceKernelCenterAccumulation);
			}
		}
	}
	else
	{
		[loop] for (int x = -KernelRadius; x <= KernelRadius; x++)
		{
			[loop] for (int y = -KernelRadius; y <= KernelRadius; y++)
			{
				const bool bIsKernelCenterSample = x == 0 && y == 0;
				if (bIsKernelCenterSample && !KernelConfig.bSampleKernelCenter) continue;
				float2 SampleOffset = float2(x, y);
				if (KernelConfig.SampleSet == 3)
				{
					SampleOffset = mul(float2x2(float2(2, -1), float2(1, 2)), SampleOffset);
				}
				float2 SampleBufferUV = KernelConfig.BufferUV + (SampleOffset * KernelConfig.KernelSpreadFactor) * KernelConfig.BufferSizeAndInvSize.zw;
				float KernelWeight = 1;
				if (KernelConfig.SampleSet == 4)
				{
					KernelWeight = 
						kWaveletFilterWeights5x5[abs(x)] *
						kWaveletFilterWeights5x5[abs(y)] *
						rcp(kWaveletFilterWeights5x5[0] * kWaveletFilterWeights5x5[0]);
				}
				SampleAndAccumulateMultiplexedSignals(
					KernelConfig,
					SignalBuffer0,
					SignalBuffer1,
					SignalBuffer2,
					SignalBuffer3,
					 UncompressedAccumulators,
					 CompressedAccumulators,
					SampleBufferUV,
					KernelWeight,
					 bIsKernelCenterSample && KernelConfig.bForceKernelCenterAccumulation);
			}
		}
	}
}
void BroadcastAccumulateSquare3x3KernelCenter(
 	FSSDKernelConfig KernelConfig,
 	inout FSSDSignalAccumulatorArray UncompressedAccumulators,
 	inout FSSDCompressedSignalAccumulatorArray CompressedAccumulators,
 	FSSDSampleSceneInfos RefSceneMetadata,
 	float2 SampleBufferUV,
 	FSSDSampleSceneInfos SampleSceneMetadata,
 	FSSDSignalArray SampleMultiplexedSamples,
	FSSDSignalFrequencyArray SampleMultiplexedFrequencies)
{
	const FWaveBroadcastSettings BroadcastSettingsX = InitWaveSwapWithinLaneGroup( 2);
	const FWaveBroadcastSettings BroadcastSettingsY = InitWaveSwapWithinLaneGroup( 16);
	SampleBufferUV = WaveBroadcast(BroadcastSettingsX, SampleBufferUV);
	SampleSceneMetadata = WaveBroadcastSceneMetadata(BroadcastSettingsX, SampleSceneMetadata);
	SampleMultiplexedSamples = WaveBroadcastSignalArray(BroadcastSettingsX, SampleMultiplexedSamples);
	SampleMultiplexedFrequencies = WaveBroadcastSignalFrequenciesArray(BroadcastSettingsX, SampleMultiplexedFrequencies);
	if (KernelConfig.SampleSet == 2 || KernelConfig.SampleSet == 5)
	{
		AccumulateSampledMultiplexedSignals(
			KernelConfig,
			 UncompressedAccumulators,
			 CompressedAccumulators,
			RefSceneMetadata,
			SampleBufferUV,
			SampleSceneMetadata,
			SampleMultiplexedSamples,
			SampleMultiplexedFrequencies,
			 1.0,
			 false,
			 false);
	}
	SampleBufferUV = WaveBroadcast(BroadcastSettingsY, SampleBufferUV);
	SampleSceneMetadata = WaveBroadcastSceneMetadata(BroadcastSettingsY, SampleSceneMetadata);
	SampleMultiplexedSamples = WaveBroadcastSignalArray(BroadcastSettingsY, SampleMultiplexedSamples);
	SampleMultiplexedFrequencies = WaveBroadcastSignalFrequenciesArray(BroadcastSettingsY, SampleMultiplexedFrequencies);
	if (KernelConfig.SampleSet == 2 || KernelConfig.SampleSet == 6)
	{
		AccumulateSampledMultiplexedSignals(
			KernelConfig,
			 UncompressedAccumulators,
			 CompressedAccumulators,
			RefSceneMetadata,
			SampleBufferUV,
			SampleSceneMetadata,
			SampleMultiplexedSamples,
			SampleMultiplexedFrequencies,
			 1.0,
			 false,
			 false);
	}
	SampleBufferUV = WaveBroadcast(BroadcastSettingsX, SampleBufferUV);
	SampleSceneMetadata = WaveBroadcastSceneMetadata(BroadcastSettingsX, SampleSceneMetadata);
	SampleMultiplexedSamples = WaveBroadcastSignalArray(BroadcastSettingsX, SampleMultiplexedSamples);
	SampleMultiplexedFrequencies = WaveBroadcastSignalFrequenciesArray(BroadcastSettingsX, SampleMultiplexedFrequencies);
	if (KernelConfig.SampleSet == 2 || KernelConfig.SampleSet == 5)
	{
		AccumulateSampledMultiplexedSignals(
			KernelConfig,
			 UncompressedAccumulators,
			 CompressedAccumulators,
			RefSceneMetadata,
			SampleBufferUV,
			SampleSceneMetadata,
			SampleMultiplexedSamples,
			SampleMultiplexedFrequencies,
			 1.0,
			 false,
			 false);
	}
}
void AccumulateSquare3x3Kernel(
	FSSDKernelConfig KernelConfig,
	Texture2D SignalBuffer0,
	Texture2D SignalBuffer1,
	Texture2D SignalBuffer2,
	Texture2D SignalBuffer3,
	inout FSSDSignalAccumulatorArray UncompressedAccumulators,
	inout FSSDCompressedSignalAccumulatorArray CompressedAccumulators)
{
	if (KernelConfig.bSampleKernelCenter)
	{
		float2 SampleBufferUV = KernelConfig.BufferUV;
		const bool bIsOutsideFrustum = false;
		FSSDCompressedSceneInfos CompressedSampleSceneMetadata;
		FSSDCompressedMultiplexedSample CompressedMultiplexedSamples;
		 
		{
			SampleMultiplexedSignals(
				KernelConfig,
				SignalBuffer0,
				SignalBuffer1,
				SignalBuffer2,
				SignalBuffer3,
				SampleBufferUV,
				 CompressedSampleSceneMetadata,
				 CompressedMultiplexedSamples);
		}
		FSSDSampleSceneInfos RefSceneMetadata = UncompressRefSceneMetadata(KernelConfig);
		FSSDSignalArray MultiplexedSamples;
		FSSDSignalFrequencyArray MultiplexedFrequencies;
		UncompressMultiplexedSignals(
			KernelConfig,
			SampleBufferUV,
			CompressedMultiplexedSamples,
			 MultiplexedSamples,
			 MultiplexedFrequencies);
		FSSDSampleSceneInfos SampleSceneMetadata = UncompressSampleSceneMetadata(
			KernelConfig, SampleBufferUV, CompressedSampleSceneMetadata);
		AccumulateSampledMultiplexedSignals(
			KernelConfig,
			 UncompressedAccumulators,
			 CompressedAccumulators,
			RefSceneMetadata,
			SampleBufferUV,
			SampleSceneMetadata,
			MultiplexedSamples,
			MultiplexedFrequencies,
			 1.0,
			 true,
			bIsOutsideFrustum);
		BroadcastAccumulateSquare3x3KernelCenter(
			KernelConfig,
			 UncompressedAccumulators,
			 CompressedAccumulators,
			RefSceneMetadata,
			SampleBufferUV,
			SampleSceneMetadata,
			MultiplexedSamples,
			MultiplexedFrequencies);
	}
	uint2 OutputPixelPostion = BufferUVToBufferPixelCoord(KernelConfig.RefBufferUV);
	bool bFlipX = (OutputPixelPostion.x & 0x1) != 0;
	bool bFlipY = (OutputPixelPostion.y & 0x1) != 0;
	if (KernelConfig.SampleSet == 2 || KernelConfig.SampleSet == 6)
	{
		float2 SampleOffset = float2(bFlipX ? 1.0 : -1.0, bFlipY ? 1.0 : -1.0);
		float2 SampleBufferUV = KernelConfig.BufferUV + SampleOffset * KernelConfig.BufferSizeAndInvSize.zw;
		SampleAndAccumulateMultiplexedSignals(
			KernelConfig,
			SignalBuffer0,
			SignalBuffer1,
			SignalBuffer2,
			SignalBuffer3,
			 UncompressedAccumulators,
			 CompressedAccumulators,
			SampleBufferUV,
			 1.0,
			 false);
	}
	static const float2 SampleOffsetArray[4] = {
		float2(-1.0,  0.0),
		float2( 0.0, -1.0),
		float2(-1.0, 1.0),
		float2( 1.0, -1.0),
	};
	[unroll]
	for (
		uint BatchId = (KernelConfig.SampleSet == 6 ? 1 : 0);
		BatchId < (KernelConfig.SampleSet == 5 ? 1 : 2);
		BatchId++)
	 
	{
		float2 SampleOffset0 =  select_internal( bool2(bFlipX, bFlipY) , -SampleOffsetArray[BatchId * 2 + 0] , SampleOffsetArray[BatchId * 2 + 0] );
		float2 SampleOffset1 =  select_internal( bool2(bFlipX, bFlipY) , -SampleOffsetArray[BatchId * 2 + 1] , SampleOffsetArray[BatchId * 2 + 1] );
		float2 SampleBufferUV[2];
		SampleBufferUV[0] = KernelConfig.BufferUV + SampleOffset0 * KernelConfig.BufferSizeAndInvSize.zw;
		SampleBufferUV[1] = KernelConfig.BufferUV + SampleOffset1 * KernelConfig.BufferSizeAndInvSize.zw;
		SampleAndAccumulateMultiplexedSignalsPair(
			KernelConfig,
			SignalBuffer0,
			SignalBuffer1,
			SignalBuffer2,
			SignalBuffer3,
			 UncompressedAccumulators,
			 CompressedAccumulators,
			SampleBufferUV,
			 1.0);
	}
}
void AccumulateRefSampleAsKernelCenter(
	FSSDKernelConfig KernelConfig,
	inout FSSDSignalAccumulatorArray UncompressedAccumulators,
	inout FSSDCompressedSignalAccumulatorArray CompressedAccumulators,
	float2 RefBufferUV,
	FSSDSampleSceneInfos RefSceneMetadata,
	FSSDSignalArray RefMultiplexedSamples,
	FSSDSignalFrequencyArray RefMultiplexedFrequencies)
{
	if (!KernelConfig.bSampleKernelCenter)
	{
		AccumulateSampledMultiplexedSignals(
			KernelConfig,
			 UncompressedAccumulators,
			 CompressedAccumulators,
			RefSceneMetadata,
			RefBufferUV,
			RefSceneMetadata,
			RefMultiplexedSamples,
			RefMultiplexedFrequencies,
			 1.0,
			 true,
			 false);
		if (KernelConfig.SampleSet == 0xDEADDEAD)
		{
		}
		else if (KernelConfig.SampleSet == 2 ||
			KernelConfig.SampleSet == 5 ||
			KernelConfig.SampleSet == 6)
		{
			BroadcastAccumulateSquare3x3KernelCenter(
				KernelConfig,
				 UncompressedAccumulators,
				 CompressedAccumulators,
				RefSceneMetadata,
				RefBufferUV,
				RefSceneMetadata,
				RefMultiplexedSamples,
				RefMultiplexedFrequencies);
		}
	}
}
void AccumulateKernel(
	FSSDKernelConfig KernelConfig,
	Texture2D SignalBuffer0,
	Texture2D SignalBuffer1,
	Texture2D SignalBuffer2,
	Texture2D SignalBuffer3,
	inout FSSDSignalAccumulatorArray UncompressedAccumulators,
	inout FSSDCompressedSignalAccumulatorArray CompressedAccumulators)
{
	if (KernelConfig.SampleSet == 0xDEADDEAD)
	{
	}
	else if (KernelConfig.SampleSet == 0)
	{
		if (KernelConfig.bSampleKernelCenter)
		{
			SampleAndAccumulateCenterSampleAsItsOwnCluster(
				KernelConfig,
				SignalBuffer0,
				SignalBuffer1,
				SignalBuffer2,
				SignalBuffer3,
				 UncompressedAccumulators,
				 CompressedAccumulators);
		}
	}
	else if (
		KernelConfig.SampleSet == 1 ||
		KernelConfig.SampleSet == 13 ||
		KernelConfig.SampleSet == 17)
	{
		AccumulateBilinear2x2Kernel(
			KernelConfig,
			SignalBuffer0,
			SignalBuffer1,
			SignalBuffer2,
			SignalBuffer3,
			 UncompressedAccumulators,
			 CompressedAccumulators);
	}
	else if (
		KernelConfig.SampleSet == 2 ||
		KernelConfig.SampleSet == 5 ||
		KernelConfig.SampleSet == 6)
	{
		AccumulateSquare3x3Kernel(
			KernelConfig,
			SignalBuffer0,
			SignalBuffer1,
			SignalBuffer2,
			SignalBuffer3,
			 UncompressedAccumulators,
			 CompressedAccumulators);
	}
	else if (
		KernelConfig.SampleSet == 3 ||
		KernelConfig.SampleSet == 4 ||
		KernelConfig.SampleSet == 7)
	{
		AccumulateSquareKernel(
			KernelConfig,
			SignalBuffer0,
			SignalBuffer1,
			SignalBuffer2,
			SignalBuffer3,
			 UncompressedAccumulators,
			 CompressedAccumulators);
	}
}
int4 bCameraCut [ (( 1 +3)/4)];
float HistoryPreExposureCorrection;
float4 ScreenPosToHistoryBufferUV;
float4 HistoryBufferSizeAndInvSize;
float4 HistoryBufferUVMinMax;
Texture2D SignalInput_Textures_0;
Texture2D SignalInput_Textures_1;
Texture2D PrevHistory_Textures_0;
RWTexture2D<float4> 	SignalHistoryOutput_UAVs_0;
Texture2D PrevHistory_Textures_1;
RWTexture2D<float4> 	SignalHistoryOutput_UAVs_1;
FSSDSignalSample TransformInputBufferForPreRejection(FSSDSignalSample Sample)
{
	return TransformSignal(
		Sample,
		 0x0,
		 0x0);
}
FSSDSignalSample TransformSignalForPostRejection(FSSDSignalSample Sample)
{
	return TransformSignal(
		Sample,
		 0x0,
		 0x0);
}
void TemporallyAccumulate(
	uint2 DispatchThreadId : SV_DispatchThreadID,
	uint2 GroupId : SV_GroupID,
	uint2 GroupThreadId : SV_GroupThreadID,
	uint GroupThreadIndex : SV_GroupIndex)
{
	float2 SceneBufferUV = DispatchThreadId * ThreadIdToBufferUV.xy + ThreadIdToBufferUV.zw;
	if (true)
	{
		SceneBufferUV = clamp(SceneBufferUV, DenoiserBufferBilinearUVMinMax.xy, DenoiserBufferBilinearUVMinMax.zw);
	}
	FSSDCompressedSceneInfos CompressedRefSceneMetadata = SampleCompressedSceneMetadata(
		 false,
		SceneBufferUV, BufferUVToBufferPixelCoord(SceneBufferUV));
	float DeviceZ;
	uint ShadingModelID;
	{
		FSSDSampleSceneInfos RefInfo = UncompressSampleSceneInfo(
			0,  false,
			DenoiserBufferUVToScreenPosition(SceneBufferUV),
			CompressedRefSceneMetadata);
		DeviceZ = RefInfo.DeviceZ;
		ShadingModelID = RefInfo.ShadingModelID;
	}
	float3 HistoryScreenPosition = float3(DenoiserBufferUVToScreenPosition(SceneBufferUV), DeviceZ);
	bool bIsDynamicPixel = false;
	if (1)
	{
		float4 ThisClip = float4(HistoryScreenPosition, 1);
		float4 PrevClip = mul(ThisClip, View.ClipToPrevClip);
		float3 PrevScreen = PrevClip.xyz * rcp(PrevClip.w);
		float3 Velocity = HistoryScreenPosition - PrevScreen;
		if (1)
		{
			float4 EncodedVelocity = GBufferVelocityTexture.SampleLevel( D3DStaticPointClampedSampler, SceneBufferUV, 0);
			bIsDynamicPixel = EncodedVelocity.x > 0.0;
			if (bIsDynamicPixel)
			{
				Velocity = DecodeVelocityFromTexture(EncodedVelocity);
			}
		}
		HistoryScreenPosition -= Velocity;
	}
	FSSDSignalArray CurrentFrameSamples;
	FSSDSignalFrequencyArray CurrentFrameFrequencies;
	SampleMultiplexedSignals(
		SignalInput_Textures_0,
		SignalInput_Textures_1,
		SignalInput_Textures_0,
		SignalInput_Textures_0,
		 D3DStaticPointClampedSampler,
		0xD101,
		 0,
		 0 != 0,
		SceneBufferUV,
		 CurrentFrameSamples,
		 CurrentFrameFrequencies);
	FSSDSignalArray HistorySamples = CreateSignalArrayFromScalarValue(0.0);
	{
		float2 HistoryBufferUV = HistoryScreenPosition.xy * ScreenPosToHistoryBufferUV.xy + ScreenPosToHistoryBufferUV.zw;
		float2 ClampedHistoryBufferUV = clamp(HistoryBufferUV, HistoryBufferUVMinMax.xy, HistoryBufferUVMinMax.zw);
		bool bIsPreviousFrameOffscreen = any(HistoryBufferUV != ClampedHistoryBufferUV);
		[branch]
		if (!bIsPreviousFrameOffscreen)
		{
			FSSDKernelConfig KernelConfig = CreateKernelConfig();
			KernelConfig.SampleSet = 1;
			KernelConfig.bSampleKernelCenter = true;
			KernelConfig.BufferLayout = 0xD102;
			KernelConfig.MultiplexedSignalsPerSignalDomain = 3;
			KernelConfig.bUnroll = true;
			KernelConfig.bPreviousFrameMetadata = true;
			KernelConfig.BilateralDistanceComputation = 2;
			KernelConfig.bClampUVPerMultiplexedSignal = 0 != 0;
			KernelConfig.WorldBluringDistanceMultiplier = max(1.0, 3.0);
			SetBilateralPreset(0x2001,  KernelConfig);
			KernelConfig.BufferSizeAndInvSize = HistoryBufferSizeAndInvSize;
			KernelConfig.BufferBilinearUVMinMax = HistoryBufferUVMinMax;
			KernelConfig.BufferUV = HistoryBufferUV + BufferUVBilinearCorrection;
			KernelConfig.bIsDynamicPixel = bIsDynamicPixel;
			{
				KernelConfig.CompressedRefSceneMetadata = CompressedRefSceneMetadata;
				KernelConfig.RefBufferUV = SceneBufferUV;
				KernelConfig.RefSceneMetadataLayout = 0;
			}
			 
			{
				KernelConfig.Randoms[0] = InterleavedGradientNoise(SceneBufferUV * BufferUVToOutputPixelPosition, View.StateFrameIndexMod8);
			}
			FSSDSignalAccumulatorArray SignalAccumulators = CreateSignalAccumulatorArray();
			FSSDCompressedSignalAccumulatorArray UnusedCompressedAccumulators = CreateUninitialisedCompressedAccumulatorArray();
			AccumulateKernel(
				KernelConfig,
				PrevHistory_Textures_0,
				PrevHistory_Textures_1,
				PrevHistory_Textures_0,
				PrevHistory_Textures_0,
				 SignalAccumulators,
				 UnusedCompressedAccumulators);
			{
				 [unroll( 1 )]
				for (uint BatchedSignalId = 0; BatchedSignalId < 1; BatchedSignalId++)
				{
					HistorySamples.Array[BatchedSignalId] = SignalAccumulators.Array[BatchedSignalId].Moment1;
					[branch]
					if (  bCameraCut [(uint) BatchedSignalId >>2u][(uint) BatchedSignalId &3u])
					{
						HistorySamples.Array[BatchedSignalId] = CreateSignalSampleFromScalarValue(0.0);
					}
				}
			}
			{
				 [unroll( 1 )]
				for (uint BatchedSignalId = 0; BatchedSignalId < 1; BatchedSignalId++)
				{
					FSSDSignalSample CurrentFrameSample = CurrentFrameSamples.Array[BatchedSignalId];
					FSSDSignalSample HistorySample = HistorySamples.Array[BatchedSignalId];
						HistorySamples.Array[BatchedSignalId].SceneColor.rgb *= HistoryPreExposureCorrection;
				} 
			}
		} 
	}
	const bool bPostRejectionBlending = true;
	{
		FSSDKernelConfig KernelConfig = CreateKernelConfig();
		{
			KernelConfig.bSampleKernelCenter = 0 != 0;
			KernelConfig.BilateralDistanceComputation = 0;
			KernelConfig.NeighborToRefComputation = 1;
			if (4 == 0)
				KernelConfig.BilateralDistanceComputation = 4;
			KernelConfig.WorldBluringDistanceMultiplier = 1.0;
			{
				KernelConfig.SampleSet = (4 == 0) ? 2 : 7;
				KernelConfig.BoxKernelRadius = 3;
				KernelConfig.bUnroll = false;
			}
			if (0)
			{
				KernelConfig.MultiplexedSignalsPerSignalDomain = 2;
				KernelConfig.BufferLayout = 0xD101;
				KernelConfig.bNormalizeSample = false;
				for (uint MultiplexId = 0; MultiplexId < 1; MultiplexId++)
				{
					KernelConfig.BufferColorSpace[MultiplexId] = 0x0;
					KernelConfig.AccumulatorColorSpace[MultiplexId] = 0x0;
				}
				KernelConfig.bForceKernelCenterAccumulation = true;
			}
			else
			{
				KernelConfig.MultiplexedSignalsPerSignalDomain = 3;
				KernelConfig.BufferLayout = 0xD101;
				KernelConfig.bNormalizeSample = true;
				for (uint MultiplexId = 0; MultiplexId < 1; MultiplexId++)
				{
					KernelConfig.AccumulatorColorSpace[MultiplexId] = 0x0;
				}
				if (1 == 1)
				{
					KernelConfig.bForceAllAccumulation = CurrentFrameSamples.Array[0].SampleCount == 0;
				}
			}
			SetBilateralPreset(0x2001,  KernelConfig);
		}
		{
			KernelConfig.BufferSizeAndInvSize = DenoiserBufferSizeAndInvSize;
			KernelConfig.BufferBilinearUVMinMax = DenoiserBufferBilinearUVMinMax;
		}
		{
			KernelConfig.BufferUV = SceneBufferUV;
			{
				KernelConfig.CompressedRefSceneMetadata = CompressedRefSceneMetadata;
				KernelConfig.RefBufferUV = SceneBufferUV;
				KernelConfig.RefSceneMetadataLayout = 0;
			}
		}
		FSSDSignalAccumulatorArray SignalAccumulators = CreateSignalAccumulatorArray();
		{
			FSSDSampleSceneInfos RefSceneMetadata = UncompressRefSceneMetadata(KernelConfig);
			FSSDCompressedSignalAccumulatorArray UnusedCompressedAccumulators = CreateUninitialisedCompressedAccumulatorArray();
			FSSDSignalArray CenterSample = CurrentFrameSamples;
			if (KernelConfig.bNormalizeSample)
			{
				CenterSample = NormalizeToOneSampleArray(CurrentFrameSamples);
			}
			AccumulateRefSampleAsKernelCenter(
				KernelConfig,
				 SignalAccumulators,
				 UnusedCompressedAccumulators,
				KernelConfig.RefBufferUV,
				RefSceneMetadata,
				CenterSample,
				CurrentFrameFrequencies);
		}
		{
			FSSDCompressedSignalAccumulatorArray UnusedCompressedAccumulators = CreateUninitialisedCompressedAccumulatorArray();
				AccumulateKernel(
					KernelConfig,
					SignalInput_Textures_0,
					SignalInput_Textures_1,
					SignalInput_Textures_0,
					SignalInput_Textures_0,
					 SignalAccumulators,
					 UnusedCompressedAccumulators);
		}
		 [unroll( 1 )]
		for (uint BatchedSignalId = 0; BatchedSignalId < 1; BatchedSignalId++)
		{
			FSSDSignalSample NeighborMoment1 = CreateSignalSampleFromScalarValue(0.0);
			FSSDSignalSample NeighborMoment2 = CreateSignalSampleFromScalarValue(0.0);
			{
				float NormalizeFactor = SafeRcp(SignalAccumulators.Array[BatchedSignalId].Moment1.SampleCount);
				NeighborMoment1 = MulSignal(SignalAccumulators.Array[BatchedSignalId].Moment1, NormalizeFactor);
			}
			FSSDSignalSample CurrentFrameSample = CurrentFrameSamples.Array[BatchedSignalId];
			FSSDSignalSample HistorySample = HistorySamples.Array[BatchedSignalId];
			{
				FSSDSignalSample NeighborMin = SignalAccumulators.Array[BatchedSignalId].Min;
				FSSDSignalSample NeighborMax = SignalAccumulators.Array[BatchedSignalId].Max;
				bool bIsValid = NeighborMax.SampleCount > 0.0;
				float RejectedSampleCount = 0;
				HistorySample = MulSignal(TransformSignalForPostRejection(ClampSignal(TransformInputBufferForPreRejection(NormalizeToOneSample(HistorySample)), NeighborMin, NeighborMax)), HistorySample.SampleCount - RejectedSampleCount);
				[flatten]
				if (!bIsValid)
				{
					HistorySample = CreateSignalSampleFromScalarValue(0.0);
				}
			}
			if (1)
			{
				CurrentFrameFrequencies.Array[BatchedSignalId] = MinSignalFrequency(
					CurrentFrameFrequencies.Array[BatchedSignalId],
					SignalAccumulators.Array[BatchedSignalId].MinFrequency);
			}
			HistorySamples.Array[BatchedSignalId] = HistorySample;
			CurrentFrameSamples.Array[BatchedSignalId] = CurrentFrameSample;
		} 
	}
	{
		[unroll]
		for (uint BatchedSignalId = 0; BatchedSignalId < 1; BatchedSignalId++)
		{
			FSSDSignalSample CurrentFrameSample = CurrentFrameSamples.Array[BatchedSignalId];
			FSSDSignalSample HistorySample = HistorySamples.Array[BatchedSignalId];
			FSSDSignalFrequency CurrentFrequency = CurrentFrameFrequencies.Array[BatchedSignalId];
			float TargetedSampleCount;
			{
				float2 ScreenPosition = DenoiserBufferUVToScreenPosition(SceneBufferUV);
				FSSDSampleSceneInfos RefSceneMetadata = UncompressSampleSceneInfo(
					0,  false,
					ScreenPosition, CompressedRefSceneMetadata);
				float PixelWorldBluringRadius = ComputeWorldBluringRadiusCausedByPixelSize(RefSceneMetadata);
				float WorldBluringRadius = WorldBluringRadiusToBilateralWorldDistance(PixelWorldBluringRadius);
				{
					TargetedSampleCount = 4096;
				}
			}
			float PreviousFrameWeight = min(HistorySample.SampleCount, TargetedSampleCount - CurrentFrameSample.SampleCount);
			float PreviousFrameMultiplier = HistorySample.SampleCount > 0 ? PreviousFrameWeight / HistorySample.SampleCount : 0;
			HistorySample = TransformSignal(
				HistorySample,
				 0x0,
				 0x0);
			CurrentFrameSample = TransformSignal(
				CurrentFrameSample,
				 0x0,
				 0x0);
			HistorySample = AddSignal(MulSignal(HistorySample, PreviousFrameMultiplier), CurrentFrameSample);
			HistorySample = TransformSignal(
				HistorySample,
				 0x0,
				 0x0);
			HistorySamples.Array[BatchedSignalId] = HistorySample;
		}
	}
	uint MultiplexCount = 1;
	FSSDSignalArray OutputSamples = CreateSignalArrayFromScalarValue(0.0);
	FSSDSignalFrequencyArray OutputFrequencies = CreateInvalidSignalFrequencyArray();
	{
		MultiplexCount = 1;
		[unroll]
		for (uint BatchedSignalId = 0; BatchedSignalId < MultiplexCount; BatchedSignalId++)
		{
			OutputSamples.Array[BatchedSignalId] = HistorySamples.Array[BatchedSignalId];
			OutputFrequencies.Array[BatchedSignalId] = CurrentFrameFrequencies.Array[BatchedSignalId];
		}
	}
	uint2 OutputPixelPostion = BufferUVToBufferPixelCoord(SceneBufferUV);
	[branch]
	if (all(OutputPixelPostion < ViewportMax))
	{
		OutputMultiplexedSignal(
			SignalHistoryOutput_UAVs_0,
			SignalHistoryOutput_UAVs_1,
			SignalHistoryOutput_UAVs_0,
			SignalHistoryOutput_UAVs_0,
			0xD102,
			MultiplexCount,
			OutputPixelPostion,
			OutputSamples,
			OutputFrequencies);
	}
}
[numthreads(8, 8, 1)]
void MainCS(
	uint2 DispatchThreadId : SV_DispatchThreadID,
	uint2 GroupId : SV_GroupID,
	uint2 GroupThreadId : SV_GroupThreadID,
	uint GroupThreadIndex : SV_GroupIndex)
{
	TemporallyAccumulate(DispatchThreadId, GroupId, GroupThreadId, GroupThreadIndex);
}

/* BASE64_ENV
BQAAABkAAABWSUVXX0hBU19USUxFT0ZGU0VUX0RBVEEAAAEAAAAeAAAAUFJJTUlUSVZFX0hBU19USUxFT0ZGU0VUX0RBVEEAAAEAAAARAAAASU5TVEFOQ0VEX1NURVJFTwAAAAAAAAsAAABNVUxUSV9WSUVXAAAAAAAAEgAAAE1PQklMRV9NVUxUSV9WSUVXAAAAAAAAIBAQIAQAAAAAAAAAmQAAAAQIAAAECAEABAUCAAQFAwAEBQQABAUFAAQFBgAEBQcABAUIAAQFCQAEBQoABAULAAQIDAAECA0ABAgOAAQIDwAECBAABAgRAAQIEgAECBMABAgUAAQFFQAEBRYABAUXAAQFGAAECBkABAgaAAQIGwAEBRwABAgdAAQFHgAECB8ABAUgAAQIIQAEBSIABAgjAAQFJAAECCUABAUmAAQIJwAECCgABAgpAAQIKgAECCsABAgsAAQILQAEBS4ABAgvAAQGMAAEBTEABAgyAAQFMwAECDQABAU1AAQINgAEBTcABAg4AAQFOQAECDoABAU7AAQIPAAEBT0ABAg+AAQFPwAECEAABAVBAAQIQgAEBUMABAhEAAQFRQAEBUYABAVHAAQFSAAECEkABAVKAAQISwAEBUwABAhNAAQFTgAECE8ABAVQAAQIUQAECFIABAVTAAQIVAAEBVUABAhWAAQGVwAEBlgABAVZAAQIWgAEBVsABAhcAAQIXQAEBl4ABAZfAAQHYAAEBmEACQkAAAkJAQAJCQIACQkDAAkQBAAJEAUAEwkAABMIAQATCQIAEwkDABMIBAATCQUAEwgGABMJBwATCAgAEwwJABMJCgATCAsAEwkMABMJDQATCQ4AEwkPABMJEAATCREAEwkSABMJEwATCBQAEwgVABMIFgATCBcAEwgYABMJAAATCQEAEwkCABMJAwATCQQAEwkFABMJBgATCQcAEwkIABMJCQATCQoAEwkLABMMDAATCA0ABRAAAAUQAQAFEAIABRADAAUQBAAFEAUABRAGAAUMBwAFDAgABQgJAAcAAAAFAAAAVmlldwAFAAAAVmlldwAaAmgVAwAAAADwDAAAVgBpAGUAdwBfAE0AYQB0AGUAcgBpAGEAbABUAGUAeAB0AHUAcgBlAEIAaQBsAGkAbgBlAGEAcgBXAHIAYQBwAGUAZABTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAE0AYQB0AGUAcgBpAGEAbABUAGUAeAB0AHUAcgBlAEIAaQBsAGkAbgBlAGEAcgBDAGwAYQBtAHAAZQBkAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8AVgBvAGwAdQBtAGUAdAByAGkAYwBMAGkAZwBoAHQAbQBhAHAASQBuAGQAaQByAGUAYwB0AGkAbwBuAFQAZQB4AHQAdQByAGUAAABWAGkAZQB3AF8AVgBvAGwAdQBtAGUAdAByAGkAYwBMAGkAZwBoAHQAbQBhAHAAQgByAGkAYwBrAEEAbQBiAGkAZQBuAHQAVgBlAGMAdABvAHIAAABWAGkAZQB3AF8AVgBvAGwAdQBtAGUAdAByAGkAYwBMAGkAZwBoAHQAbQBhAHAAQgByAGkAYwBrAFMASABDAG8AZQBmAGYAaQBjAGkAZQBuAHQAcwAwAAAAVgBpAGUAdwBfAFYAbwBsAHUAbQBlAHQAcgBpAGMATABpAGcAaAB0AG0AYQBwAEIAcgBpAGMAawBTAEgAQwBvAGUAZgBmAGkAYwBpAGUAbgB0AHMAMQAAAFYAaQBlAHcAXwBWAG8AbAB1AG0AZQB0AHIAaQBjAEwAaQBnAGgAdABtAGEAcABCAHIAaQBjAGsAUwBIAEMAbwBlAGYAZgBpAGMAaQBlAG4AdABzADIAAABWAGkAZQB3AF8AVgBvAGwAdQBtAGUAdAByAGkAYwBMAGkAZwBoAHQAbQBhAHAAQgByAGkAYwBrAFMASABDAG8AZQBmAGYAaQBjAGkAZQBuAHQAcwAzAAAAVgBpAGUAdwBfAFYAbwBsAHUAbQBlAHQAcgBpAGMATABpAGcAaAB0AG0AYQBwAEIAcgBpAGMAawBTAEgAQwBvAGUAZgBmAGkAYwBpAGUAbgB0AHMANAAAAFYAaQBlAHcAXwBWAG8AbAB1AG0AZQB0AHIAaQBjAEwAaQBnAGgAdABtAGEAcABCAHIAaQBjAGsAUwBIAEMAbwBlAGYAZgBpAGMAaQBlAG4AdABzADUAAABWAGkAZQB3AF8AUwBrAHkAQgBlAG4AdABOAG8AcgBtAGEAbABCAHIAaQBjAGsAVABlAHgAdAB1AHIAZQAAAFYAaQBlAHcAXwBEAGkAcgBlAGMAdABpAG8AbgBhAGwATABpAGcAaAB0AFMAaABhAGQAbwB3AGkAbgBnAEIAcgBpAGMAawBUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAFYAbwBsAHUAbQBlAHQAcgBpAGMATABpAGcAaAB0AG0AYQBwAEIAcgBpAGMAawBBAG0AYgBpAGUAbgB0AFYAZQBjAHQAbwByAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8AVgBvAGwAdQBtAGUAdAByAGkAYwBMAGkAZwBoAHQAbQBhAHAAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByADAAAABWAGkAZQB3AF8AVgBvAGwAdQBtAGUAdAByAGkAYwBMAGkAZwBoAHQAbQBhAHAAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByADEAAABWAGkAZQB3AF8AVgBvAGwAdQBtAGUAdAByAGkAYwBMAGkAZwBoAHQAbQBhAHAAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByADIAAABWAGkAZQB3AF8AVgBvAGwAdQBtAGUAdAByAGkAYwBMAGkAZwBoAHQAbQBhAHAAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByADMAAABWAGkAZQB3AF8AVgBvAGwAdQBtAGUAdAByAGkAYwBMAGkAZwBoAHQAbQBhAHAAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByADQAAABWAGkAZQB3AF8AVgBvAGwAdQBtAGUAdAByAGkAYwBMAGkAZwBoAHQAbQBhAHAAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByADUAAABWAGkAZQB3AF8AUwBrAHkAQgBlAG4AdABOAG8AcgBtAGEAbABUAGUAeAB0AHUAcgBlAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8ARABpAHIAZQBjAHQAaQBvAG4AYQBsAEwAaQBnAGgAdABTAGgAYQBkAG8AdwBpAG4AZwBUAGUAeAB0AHUAcgBlAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8ARwBsAG8AYgBhAGwARABpAHMAdABhAG4AYwBlAEYAaQBlAGwAZABQAGEAZwBlAEEAdABsAGEAcwBUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAEcAbABvAGIAYQBsAEQAaQBzAHQAYQBuAGMAZQBGAGkAZQBsAGQAQwBvAHYAZQByAGEAZwBlAEEAdABsAGEAcwBUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAEcAbABvAGIAYQBsAEQAaQBzAHQAYQBuAGMAZQBGAGkAZQBsAGQAUABhAGcAZQBUAGEAYgBsAGUAVABlAHgAdAB1AHIAZQAAAFYAaQBlAHcAXwBHAGwAbwBiAGEAbABEAGkAcwB0AGEAbgBjAGUARgBpAGUAbABkAE0AaQBwAFQAZQB4AHQAdQByAGUAAABWAGkAZQB3AF8ARwBsAG8AYgBhAGwARABpAHMAdABhAG4AYwBlAEYAaQBlAGwAZABQAGEAZwBlAEEAdABsAGEAcwBUAGUAeAB0AHUAcgBlAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8ARwBsAG8AYgBhAGwARABpAHMAdABhAG4AYwBlAEYAaQBlAGwAZABDAG8AdgBlAHIAYQBnAGUAQQB0AGwAYQBzAFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBHAGwAbwBiAGEAbABEAGkAcwB0AGEAbgBjAGUARgBpAGUAbABkAE0AaQBwAFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBBAHQAbQBvAHMAcABoAGUAcgBlAFQAcgBhAG4AcwBtAGkAdAB0AGEAbgBjAGUAVABlAHgAdAB1AHIAZQAAAFYAaQBlAHcAXwBBAHQAbQBvAHMAcABoAGUAcgBlAFQAcgBhAG4AcwBtAGkAdAB0AGEAbgBjAGUAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAEEAdABtAG8AcwBwAGgAZQByAGUASQByAHIAYQBkAGkAYQBuAGMAZQBUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAEEAdABtAG8AcwBwAGgAZQByAGUASQByAHIAYQBkAGkAYQBuAGMAZQBUAGUAeAB0AHUAcgBlAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8AQQB0AG0AbwBzAHAAaABlAHIAZQBJAG4AcwBjAGEAdAB0AGUAcgBUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAEEAdABtAG8AcwBwAGgAZQByAGUASQBuAHMAYwBhAHQAdABlAHIAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAFAAZQByAGwAaQBuAE4AbwBpAHMAZQBHAHIAYQBkAGkAZQBuAHQAVABlAHgAdAB1AHIAZQAAAFYAaQBlAHcAXwBQAGUAcgBsAGkAbgBOAG8AaQBzAGUARwByAGEAZABpAGUAbgB0AFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBQAGUAcgBsAGkAbgBOAG8AaQBzAGUAMwBEAFQAZQB4AHQAdQByAGUAAABWAGkAZQB3AF8AUABlAHIAbABpAG4ATgBvAGkAcwBlADMARABUAGUAeAB0AHUAcgBlAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8AUwBvAGIAbwBsAFMAYQBtAHAAbABpAG4AZwBUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAFMAaABhAHIAZQBkAFAAbwBpAG4AdABXAHIAYQBwAHAAZQBkAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8AUwBoAGEAcgBlAGQAUABvAGkAbgB0AEMAbABhAG0AcABlAGQAUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBTAGgAYQByAGUAZABCAGkAbABpAG4AZQBhAHIAVwByAGEAcABwAGUAZABTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAFMAaABhAHIAZQBkAEIAaQBsAGkAbgBlAGEAcgBDAGwAYQBtAHAAZQBkAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8AUwBoAGEAcgBlAGQAQgBpAGwAaQBuAGUAYQByAEEAbgBpAHMAbwBDAGwAYQBtAHAAZQBkAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8AUwBoAGEAcgBlAGQAVAByAGkAbABpAG4AZQBhAHIAVwByAGEAcABwAGUAZABTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAFMAaABhAHIAZQBkAFQAcgBpAGwAaQBuAGUAYQByAEMAbABhAG0AcABlAGQAUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBQAHIAZQBJAG4AdABlAGcAcgBhAHQAZQBkAEIAUgBEAEYAAABWAGkAZQB3AF8AUAByAGUASQBuAHQAZQBnAHIAYQB0AGUAZABCAFIARABGAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8AUwBrAHkASQByAHIAYQBkAGkAYQBuAGMAZQBFAG4AdgBpAHIAbwBuAG0AZQBuAHQATQBhAHAAAABWAGkAZQB3AF8AVAByAGEAbgBzAG0AaQB0AHQAYQBuAGMAZQBMAHUAdABUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAFQAcgBhAG4AcwBtAGkAdAB0AGEAbgBjAGUATAB1AHQAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAFMAawB5AFYAaQBlAHcATAB1AHQAVABlAHgAdAB1AHIAZQAAAFYAaQBlAHcAXwBTAGsAeQBWAGkAZQB3AEwAdQB0AFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBEAGkAcwB0AGEAbgB0AFMAawB5AEwAaQBnAGgAdABMAHUAdABUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAEQAaQBzAHQAYQBuAHQAUwBrAHkATABpAGcAaAB0AEwAdQB0AFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBDAGEAbQBlAHIAYQBBAGUAcgBpAGEAbABQAGUAcgBzAHAAZQBjAHQAaQB2AGUAVgBvAGwAdQBtAGUAAABWAGkAZQB3AF8AQwBhAG0AZQByAGEAQQBlAHIAaQBhAGwAUABlAHIAcwBwAGUAYwB0AGkAdgBlAFYAbwBsAHUAbQBlAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8AQwBhAG0AZQByAGEAQQBlAHIAaQBhAGwAUABlAHIAcwBwAGUAYwB0AGkAdgBlAFYAbwBsAHUAbQBlAE0AaQBlAE8AbgBsAHkAAABWAGkAZQB3AF8AQwBhAG0AZQByAGEAQQBlAHIAaQBhAGwAUABlAHIAcwBwAGUAYwB0AGkAdgBlAFYAbwBsAHUAbQBlAE0AaQBlAE8AbgBsAHkAUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBDAGEAbQBlAHIAYQBBAGUAcgBpAGEAbABQAGUAcgBzAHAAZQBjAHQAaQB2AGUAVgBvAGwAdQBtAGUAUgBhAHkATwBuAGwAeQAAAFYAaQBlAHcAXwBDAGEAbQBlAHIAYQBBAGUAcgBpAGEAbABQAGUAcgBzAHAAZQBjAHQAaQB2AGUAVgBvAGwAdQBtAGUAUgBhAHkATwBuAGwAeQBTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAEgAYQBpAHIAUwBjAGEAdAB0AGUAcgBpAG4AZwBMAFUAVABUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAEgAYQBpAHIAUwBjAGEAdAB0AGUAcgBpAG4AZwBMAFUAVABTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAEcARwBYAEwAVABDAE0AYQB0AFQAZQB4AHQAdQByAGUAAABWAGkAZQB3AF8ARwBHAFgATABUAEMATQBhAHQAUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBHAEcAWABMAFQAQwBBAG0AcABUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAEcARwBYAEwAVABDAEEAbQBwAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8AUwBoAGUAZQBuAEwAVABDAFQAZQB4AHQAdQByAGUAAABWAGkAZQB3AF8AUwBoAGUAZQBuAEwAVABDAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8AUwBoAGEAZABpAG4AZwBFAG4AZQByAGcAeQBHAEcAWABTAHAAZQBjAFQAZQB4AHQAdQByAGUAAABWAGkAZQB3AF8AUwBoAGEAZABpAG4AZwBFAG4AZQByAGcAeQBHAEcAWABHAGwAYQBzAHMAVABlAHgAdAB1AHIAZQAAAFYAaQBlAHcAXwBTAGgAYQBkAGkAbgBnAEUAbgBlAHIAZwB5AEMAbABvAHQAaABTAHAAZQBjAFQAZQB4AHQAdQByAGUAAABWAGkAZQB3AF8AUwBoAGEAZABpAG4AZwBFAG4AZQByAGcAeQBEAGkAZgBmAHUAcwBlAFQAZQB4AHQAdQByAGUAAABWAGkAZQB3AF8AUwBoAGEAZABpAG4AZwBFAG4AZQByAGcAeQBTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAEcAbABpAG4AdABUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAEcAbABpAG4AdABTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAFMAaQBtAHAAbABlAFYAbwBsAHUAbQBlAFQAZQB4AHQAdQByAGUAAABWAGkAZQB3AF8AUwBpAG0AcABsAGUAVgBvAGwAdQBtAGUAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAFMAaQBtAHAAbABlAFYAbwBsAHUAbQBlAEUAbgB2AFQAZQB4AHQAdQByAGUAAABWAGkAZQB3AF8AUwBpAG0AcABsAGUAVgBvAGwAdQBtAGUARQBuAHYAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAFMAUwBQAHIAbwBmAGkAbABlAHMAVABlAHgAdAB1AHIAZQAAAFYAaQBlAHcAXwBTAFMAUAByAG8AZgBpAGwAZQBzAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8AUwBTAFAAcgBvAGYAaQBsAGUAcwBUAHIAYQBuAHMAbQBpAHMAcwBpAG8AbgBTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAFMAUwBQAHIAbwBmAGkAbABlAHMAUAByAGUASQBuAHQAZQBnAHIAYQB0AGUAZABUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAFMAUwBQAHIAbwBmAGkAbABlAHMAUAByAGUASQBuAHQAZQBnAHIAYQB0AGUAZABTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAFMAcABlAGMAdQBsAGEAcgBQAHIAbwBmAGkAbABlAFQAZQB4AHQAdQByAGUAAABWAGkAZQB3AF8AUwBwAGUAYwB1AGwAYQByAFAAcgBvAGYAaQBsAGUAUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBXAGEAdABlAHIASQBuAGQAaQByAGUAYwB0AGkAbwBuAAAAVgBpAGUAdwBfAFcAYQB0AGUAcgBEAGEAdABhAAAAVgBpAGUAdwBfAFIAZQBjAHQATABpAGcAaAB0AEEAdABsAGEAcwBUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAFIAZQBjAHQATABpAGcAaAB0AEEAdABsAGEAcwBTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAEkARQBTAEEAdABsAGEAcwBUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAEkARQBTAEEAdABsAGEAcwBTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAEwAYQBuAGQAcwBjAGEAcABlAFcAZQBpAGcAaAB0AG0AYQBwAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8ATABhAG4AZABzAGMAYQBwAGUASQBuAGQAaQByAGUAYwB0AGkAbwBuAAAAVgBpAGUAdwBfAEwAYQBuAGQAcwBjAGEAcABlAFAAZQByAEMAbwBtAHAAbwBuAGUAbgB0AEQAYQB0AGEAAABWAGkAZQB3AF8AVgBUAEYAZQBlAGQAYgBhAGMAawBCAHUAZgBmAGUAcgAAAFYAaQBlAHcAXwBQAGgAeQBzAGkAYwBzAEYAaQBlAGwAZABDAGwAaQBwAG0AYQBwAEIAdQBmAGYAZQByAAAACgAAAFN1YnN0cmF0ZQAAAAAAQRFwCQEAAAAAvAAAAFMAdQBiAHMAdAByAGEAdABlAF8ATQBhAHQAZQByAGkAYQBsAFQAZQB4AHQAdQByAGUAQQByAHIAYQB5AAAAUwB1AGIAcwB0AHIAYQB0AGUAXwBUAG8AcABMAGEAeQBlAHIAVABlAHgAdAB1AHIAZQAAAFMAdQBiAHMAdAByAGEAdABlAF8ATwBwAGEAcQB1AGUAUgBvAHUAZwBoAFIAZQBmAHIAYQBjAHQAaQBvAG4AVABlAHgAdAB1AHIAZQAAAFMAdQBiAHMAdAByAGEAdABlAF8AQwBsAG8AcwB1AHIAZQBPAGYAZgBzAGUAdABUAGUAeAB0AHUAcgBlAAAAUwB1AGIAcwB0AHIAYQB0AGUAXwBDAGwAbwBzAHUAcgBlAFQAaQBsAGUAQgB1AGYAZgBlAHIAAABTAHUAYgBzAHQAcgBhAHQAZQBfAEMAbABvAHMAdQByAGUAVABpAGwAZQBDAG8AdQBuAHQAQgB1AGYAZgBlAHIAAAAYAAAARHJhd1JlY3RhbmdsZVBhcmFtZXRlcnMAAAAAAAABMAABAAAAAAAAAAAOAAAASW5zdGFuY2VkVmlldwAOAAAASW5zdGFuY2VkVmlldwABA7AcAwAAAAAAAAAAFAAAAE1vYmlsZVNjZW5lVGV4dHVyZXMADgAAAFNjZW5lVGV4dHVyZXMAyALQBQIAAAAAGgQAAE0AbwBiAGkAbABlAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBTAGMAZQBuAGUAQwBvAGwAbwByAFQAZQB4AHQAdQByAGUAAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8AUwBjAGUAbgBlAEMAbwBsAG8AcgBUAGUAeAB0AHUAcgBlAFMAYQBtAHAAbABlAHIAAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8AUwBjAGUAbgBlAEQAZQBwAHQAaABUAGUAeAB0AHUAcgBlAAAATQBvAGIAaQBsAGUAUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBfAFMAYwBlAG4AZQBEAGUAcAB0AGgAVABlAHgAdAB1AHIAZQBBAHIAcgBhAHkAAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8AUwBjAGUAbgBlAEQAZQBwAHQAaABUAGUAeAB0AHUAcgBlAFMAYQBtAHAAbABlAHIAAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8AUwBjAGUAbgBlAFAAYQByAHQAaQBhAGwARABlAHAAdABoAFQAZQB4AHQAdQByAGUAAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8AUwBjAGUAbgBlAFAAYQByAHQAaQBhAGwARABlAHAAdABoAFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAAAE0AbwBiAGkAbABlAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBDAHUAcwB0AG8AbQBEAGUAcAB0AGgAVABlAHgAdAB1AHIAZQAAAE0AbwBiAGkAbABlAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBDAHUAcwB0AG8AbQBEAGUAcAB0AGgAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByAAAATQBvAGIAaQBsAGUAUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBfAEMAdQBzAHQAbwBtAFMAdABlAG4AYwBpAGwAVABlAHgAdAB1AHIAZQAAAE0AbwBiAGkAbABlAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBTAGMAZQBuAGUAVgBlAGwAbwBjAGkAdAB5AFQAZQB4AHQAdQByAGUAAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8AUwBjAGUAbgBlAFYAZQBsAG8AYwBpAHQAeQBUAGUAeAB0AHUAcgBlAFMAYQBtAHAAbABlAHIAAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8ARwBCAHUAZgBmAGUAcgBBAFQAZQB4AHQAdQByAGUAAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8ARwBCAHUAZgBmAGUAcgBCAFQAZQB4AHQAdQByAGUAAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8ARwBCAHUAZgBmAGUAcgBDAFQAZQB4AHQAdQByAGUAAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8ARwBCAHUAZgBmAGUAcgBEAFQAZQB4AHQAdQByAGUAAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8AUwBjAGUAbgBlAEQAZQBwAHQAaABBAHUAeABUAGUAeAB0AHUAcgBlAAAATQBvAGIAaQBsAGUAUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBfAFMAYwBlAG4AZQBEAGUAcAB0AGgAQQB1AHgAVABlAHgAdAB1AHIAZQBBAHIAcgBhAHkAAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8ATABvAGMAYQBsAEwAaQBnAGgAdABUAGUAeAB0AHUAcgBlAEEAAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8ATABvAGMAYQBsAEwAaQBnAGgAdABUAGUAeAB0AHUAcgBlAEIAAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8ARwBCAHUAZgBmAGUAcgBBAFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAAAE0AbwBiAGkAbABlAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBHAEIAdQBmAGYAZQByAEIAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByAAAATQBvAGIAaQBsAGUAUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBfAEcAQgB1AGYAZgBlAHIAQwBUAGUAeAB0AHUAcgBlAFMAYQBtAHAAbABlAHIAAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8ARwBCAHUAZgBmAGUAcgBEAFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAAAE0AbwBiAGkAbABlAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBTAGMAZQBuAGUARABlAHAAdABoAEEAdQB4AFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAAABQAAABTY2VuZVRleHR1cmVzU3RydWN0AA4AAABTY2VuZVRleHR1cmVzAAgOcAkCAAAAABsCAABTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAFMAdAByAHUAYwB0AF8AUwBjAGUAbgBlAEMAbwBsAG8AcgBUAGUAeAB0AHUAcgBlAAAAUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBTAHQAcgB1AGMAdABfAFMAYwBlAG4AZQBEAGUAcAB0AGgAVABlAHgAdAB1AHIAZQAAAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAUwB0AHIAdQBjAHQAXwBTAGMAZQBuAGUAUABhAHIAdABpAGEAbABEAGUAcAB0AGgAVABlAHgAdAB1AHIAZQAAAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAUwB0AHIAdQBjAHQAXwBHAEIAdQBmAGYAZQByAEEAVABlAHgAdAB1AHIAZQAAAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAUwB0AHIAdQBjAHQAXwBHAEIAdQBmAGYAZQByAEIAVABlAHgAdAB1AHIAZQAAAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAUwB0AHIAdQBjAHQAXwBHAEIAdQBmAGYAZQByAEMAVABlAHgAdAB1AHIAZQAAAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAUwB0AHIAdQBjAHQAXwBHAEIAdQBmAGYAZQByAEQAVABlAHgAdAB1AHIAZQAAAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAUwB0AHIAdQBjAHQAXwBHAEIAdQBmAGYAZQByAEUAVABlAHgAdAB1AHIAZQAAAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAUwB0AHIAdQBjAHQAXwBHAEIAdQBmAGYAZQByAEYAVABlAHgAdAB1AHIAZQAAAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAUwB0AHIAdQBjAHQAXwBHAEIAdQBmAGYAZQByAFYAZQBsAG8AYwBpAHQAeQBUAGUAeAB0AHUAcgBlAAAAUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBTAHQAcgB1AGMAdABfAFMAYwByAGUAZQBuAFMAcABhAGMAZQBBAE8AVABlAHgAdAB1AHIAZQAAAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAUwB0AHIAdQBjAHQAXwBDAHUAcwB0AG8AbQBEAGUAcAB0AGgAVABlAHgAdAB1AHIAZQAAAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAUwB0AHIAdQBjAHQAXwBDAHUAcwB0AG8AbQBTAHQAZQBuAGMAaQBsAFQAZQB4AHQAdQByAGUAAABTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAFMAdAByAHUAYwB0AF8AUABvAGkAbgB0AEMAbABhAG0AcABTAGEAbQBwAGwAZQByAAAABgAAAFNjZW5lAAYAAABTY2VuZQBRH4wAAwAAAAB1AQAAUwBjAGUAbgBlAF8ARwBQAFUAUwBjAGUAbgBlAF8ARwBQAFUAUwBjAGUAbgBlAEkAbgBzAHQAYQBuAGMAZQBTAGMAZQBuAGUARABhAHQAYQAAAFMAYwBlAG4AZQBfAEcAUABVAFMAYwBlAG4AZQBfAEcAUABVAFMAYwBlAG4AZQBJAG4AcwB0AGEAbgBjAGUAUABhAHkAbABvAGEAZABEAGEAdABhAAAAUwBjAGUAbgBlAF8ARwBQAFUAUwBjAGUAbgBlAF8ARwBQAFUAUwBjAGUAbgBlAFAAcgBpAG0AaQB0AGkAdgBlAFMAYwBlAG4AZQBEAGEAdABhAAAAUwBjAGUAbgBlAF8ARwBQAFUAUwBjAGUAbgBlAF8ARwBQAFUAUwBjAGUAbgBlAEwAaQBnAGgAdABtAGEAcABEAGEAdABhAAAAUwBjAGUAbgBlAF8ARwBQAFUAUwBjAGUAbgBlAF8ARwBQAFUAUwBjAGUAbgBlAEwAaQBnAGgAdABEAGEAdABhAAAAUwBjAGUAbgBlAF8ATgBhAG4AaQB0AGUATQBhAHQAZQByAGkAYQBsAHMAXwBQAHIAaQBtAGkAdABpAHYAZQBNAGEAdABlAHIAaQBhAGwARABhAHQAYQAAAFMAYwBlAG4AZQBfAE4AYQBuAGkAdABlAE0AYQB0AGUAcgBpAGEAbABzAF8ATQBhAHQAZQByAGkAYQBsAEQAYQB0AGEAAABTAGMAZQBuAGUAXwBTAHAAbABpAG4AZQBNAGUAcwBoAF8AUwBwAGwAaQBuAGUAUABvAHMAVABlAHgAdAB1AHIAZQAAAFMAYwBlAG4AZQBfAFMAcABsAGkAbgBlAE0AZQBzAGgAXwBTAHAAbABpAG4AZQBSAG8AdABUAGUAeAB0AHUAcgBlAAAAUwBjAGUAbgBlAF8AUwBwAGwAaQBuAGUATQBlAHMAaABfAFMAcABsAGkAbgBlAFMAYQBtAHAAbABlAHIAAAAAAAAA
BASE64_ENV */
/* DIRECT COMPILE
-directcompile -format=PCD3D_SM6 -entry="MainCS" -shaderPlatformName=PCD3D_SM6 -supportedHardwareMask=0 -cs D:/Josh/Unreal Projects/WW/Saved/ShaderDebugInfo/PCD3D_SM6/Global/FSSDTemporalAccumulationCS/4/SSDTemporalAccumulation.usf -nocrashreports
DIRECT COMPILE */
